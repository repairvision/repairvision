/*
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.generator

import java.util.Collections
import java.util.Map
import java.util.Objects
import java.util.regex.Pattern
import java.util.stream.Stream
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EEnumLiteral
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sidiff.validation.laguage.fol.firstOrderLogic.And
import org.sidiff.validation.laguage.fol.firstOrderLogic.BoolConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.Capitalize
import org.sidiff.validation.laguage.fol.firstOrderLogic.Concatenate
import org.sidiff.validation.laguage.fol.firstOrderLogic.Constraint
import org.sidiff.validation.laguage.fol.firstOrderLogic.ConstraintLibrary
import org.sidiff.validation.laguage.fol.firstOrderLogic.Equals
import org.sidiff.validation.laguage.fol.firstOrderLogic.Exists
import org.sidiff.validation.laguage.fol.firstOrderLogic.ForAll
import org.sidiff.validation.laguage.fol.firstOrderLogic.Formula
import org.sidiff.validation.laguage.fol.firstOrderLogic.Get
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetClosure
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainer
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainments
import org.sidiff.validation.laguage.fol.firstOrderLogic.Greater
import org.sidiff.validation.laguage.fol.firstOrderLogic.GreaterEqual
import org.sidiff.validation.laguage.fol.firstOrderLogic.If
import org.sidiff.validation.laguage.fol.firstOrderLogic.Iff
import org.sidiff.validation.laguage.fol.firstOrderLogic.IndexOf
import org.sidiff.validation.laguage.fol.firstOrderLogic.IntConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsEmpty
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsInstanceOf
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsValueLiteralOf
import org.sidiff.validation.laguage.fol.firstOrderLogic.MetaConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.Not
import org.sidiff.validation.laguage.fol.firstOrderLogic.Or
import org.sidiff.validation.laguage.fol.firstOrderLogic.Select
import org.sidiff.validation.laguage.fol.firstOrderLogic.Size
import org.sidiff.validation.laguage.fol.firstOrderLogic.Smaller
import org.sidiff.validation.laguage.fol.firstOrderLogic.SmallerEqual
import org.sidiff.validation.laguage.fol.firstOrderLogic.StringConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.Term
import org.sidiff.validation.laguage.fol.firstOrderLogic.Variable
import org.sidiff.validation.laguage.fol.firstOrderLogic.VariableRef
import org.sidiff.validation.laguage.fol.firstOrderLogic.Xor
import org.eclipse.emf.ecore.ENamedElement

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 // FIXME: Bind scope of variables to quantifiers!
class FirstOrderLogicGenerator extends AbstractGenerator {

	val Map<Object,String> names = newHashMap

	val META_TYPE_SEPERATION_PATTERN = Pattern.compile("(?<=[a-z])(?=[A-Z])");

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val library = resource.contents.head as ConstraintLibrary
		if(library === null) {
			return
		}

		val className = generateJavaClass(library, fsa)
		generatePluginXml(className, fsa)
		saveAsXMI(resource)
	}

	private def generateJavaClass(ConstraintLibrary library, IFileSystemAccess2 fsa) {
		val className = library.javaClassName
		val packageName = library.javaPackageName

		fsa.generateFile(
			packageName.replace('.', '/') + '/' + className + '.java',
			library.toJavaCode(className, packageName))
			
		return packageName + '.' + className
	}
	
	private def toJavaCode(ConstraintLibrary library, String className, String packageName) {
		initNames(library)

		'''
		package «packageName»;
		
		import java.util.function.*;
		
		import org.sidiff.validation.constraint.api.library.*;
		
		import org.sidiff.validation.constraint.interpreter.*;
		import org.sidiff.validation.constraint.interpreter.formulas.*;
		import org.sidiff.validation.constraint.interpreter.formulas.binary.*;
		import org.sidiff.validation.constraint.interpreter.formulas.predicates.*;
		import org.sidiff.validation.constraint.interpreter.formulas.quantifiers.*;
		import org.sidiff.validation.constraint.interpreter.formulas.unary.*;
		import org.sidiff.validation.constraint.interpreter.terms.*;
		import org.sidiff.validation.constraint.interpreter.terms.functions.*;
		
		@SuppressWarnings("all")
		public class «className» extends AbstractConstraintLibrary {

			@Override
			protected void addDocumentTypes(Consumer<String> acceptor) {
				«FOR uri : library.relevantDomainUris»
				acceptor.accept("«uri»");
				«ENDFOR»
			}

			@Override
			protected void addConstraints(Consumer<IConstraint> acceptor) {
				«FOR constraint : library.constraints»
				acceptor.accept(«constraint.compileMethodName»());
				«ENDFOR»
			}
			«FOR constraint : library.constraints»
			
			private static IConstraint «constraint.compileMethodName»() {
				«constraint.compileConstraint»
			}
			«ENDFOR»
		}
		'''
	}

	private def void initNames(ConstraintLibrary library) {
		names.clear

		// Map package nsURI to package name for compilation of meta types
		library.imports.forEach[i |
			val packageImport = Platform.extensionRegistry.getConfigurationElementsFor("org.eclipse.emf.ecore.generated_package")
				.filter[getAttribute("uri") == i.domain]
				.map[getAttribute("class")]
				.head
			if(packageImport === null) {
				throw new IllegalArgumentException("Package is not registered: " + i.domain)
			}
			names.put(i.domain, packageImport)
		]
	}

	private def getRelevantDomainUris(ConstraintLibrary library) {
		return library.constraints.stream
			.flatMap[Stream.of(type, variable.type)]
			.filter[Objects::nonNull(it)]
			.map[EPackage.nsURI]
			.distinct
			.sorted
			.toArray
	}

	private def String getJavaClassName(ConstraintLibrary library) {
		return library.eResource.URI.trimFileExtension.lastSegment
	}

	private def getJavaPackageName(ConstraintLibrary library) {
		var String packageName = null; // null if src segment not yet found
		for(segment : library.eResource.URI.trimSegments(1).segments) { // trim filename first
			if(packageName === null && segment == "src") {
				packageName = '';
			} else if(packageName !== null) {
				if(!packageName.empty) {
					packageName += '.'
				}
				packageName += segment
			}
		}
		if(packageName === null) {
			throw new IllegalStateException("FOL file must be contained in the 'src' folder")
		}
		return packageName
	}

	private def generatePluginXml(String extensionClass, IFileSystemAccess2 fsa) {
		fsa.generateFile(
			'plugin.xml',
			FirstOrderLogicOutputConfigurationProvider::PROJECT_ROOT,
			'''
			<?xml version="1.0" encoding="UTF-8"?>
			<?eclipse version="3.4"?>
			<!-- Generated by FirstOrderLogicGenerator. Do not modify. File will be overridden. -->
			<plugin>
			   <extension
			         point="org.sidiff.validation.constraint.api.library">
			      <library
			            library="«extensionClass»">
			      </library>
			   </extension>
			</plugin>
			''')
	}

	private def String newName(Object astNode, String name) {
		var newName = name
		var i = 0
		while (names.containsKey(newName)) {
			i++
			newName = name + i
		}
		names.put(astNode, newName)
		return name
	}

	private def String compileMethodName(Constraint constraint) {
		'''create«constraint.name»Rule'''
	}

	private def String compileConstraint(Constraint constraint) {
		var variableCounter = 0
		var formulaName = newName(constraint, 'constraint' + '_' + constraint.name);

		'''
		«FOR variable : EcoreUtil2.eAllOfType(constraint, Variable)»
			«compileVariable(variable, variableCounter++)»
		«ENDFOR»

		Formula «formulaName» = «compileFormula(constraint.formula)»;

		return new Constraint(
			"«constraint.name»",
			"«constraint.message»",
			«compileType(constraint.type)»,
			«compileType(constraint.variable.type)»,
			«compileVariable(constraint.variable)»,
			«formulaName»);'''
	}

	private def String compileVariable(Variable variable, int counter) {
		var name = 'v' + counter + '_' + variable.name;
		name = newName(variable, name);
		
		'''Variable «name» = new Variable("«variable.name»", «compileType(variable.type)»);'''
	}

	private def String compileVariable(Variable variable) {
		return names.get(variable)
	}

	private def String compileGet(String parentTerm, Get get) {
		if(get === null) {
			parentTerm
		} else {
			compileGet(
				'''
				new Get(
					«parentTerm»,
					«compileFeature(get.name)»)''',
				get.next)			
		}
	}



	//////////////////////////////////////////////////////////
	// Meta Types
	//
	// These use the Literals constants because of edge cases where using
	// eINSTANCE.getX would not work, e.g. for UML "Class", because the function already
	// exists and would be named getClass_() instead.

	private def String compileType(EClassifier type) {
		if(type === null) {
			'null'
		} else {
			'''«type.toQualifiedPackageClass».Literals.«type.toMetaLiteralName»'''
		}
	}

	private def String compileFeature(EStructuralFeature feature) {
		'''«feature.EContainingClass.toQualifiedPackageClass».Literals.«feature.EContainingClass.toMetaLiteralName»__«feature.toMetaLiteralName»'''
	}

	private def String compileEnumLiteral(EEnumLiteral literal) {
		'''«literal.EEnum.toQualifiedPackageClass».Literals.«literal.EEnum.toMetaLiteralName».getEEnumLiteral(«literal.value»)'''
	}

	private def String toMetaLiteralName(ENamedElement namedElement) {
		// Convert first character of name to upper case because of features like eType
		val matcher = META_TYPE_SEPERATION_PATTERN.matcher(namedElement.name.toFirstUpper)
		return matcher.replaceAll('_').toUpperCase
	}

	private def String toQualifiedPackageClass(EClassifier classifier) {
		return names.get(classifier.EPackage.nsURI)
	}



	//////////////////////////////////////////////////////////
	// Formulas

	private def dispatch String compileFormula(Formula formula) {
		throw new UnsupportedOperationException('Generator not implemented for formula: ' + formula)
	}
	
	private def dispatch String compileFormula(Iff iff) {
		'''
		new Iff(
			«compileFormula(iff.left)»,
			«compileFormula(iff.right)»)'''
	}

	private def dispatch String compileFormula(If ifFormula) {
		'''
		new If(
			«compileFormula(ifFormula.left)»,
			«compileFormula(ifFormula.right)»)'''
	}

	private def dispatch String compileFormula(Xor xor) {
		'''
		new Xor(
			«compileFormula(xor.left)»,
			«compileFormula(xor.right)»)'''
	}

	private def dispatch String compileFormula(Or or) {
		'''
		new Or(
			«compileFormula(or.left)»,
			«compileFormula(or.right)»)'''
	}

	private def dispatch String compileFormula(And and) {
		'''
		new And(
			«compileFormula(and.left)»,
			«compileFormula(and.right)»)'''
	}
	
	private def dispatch String compileFormula(Not not) {
		'''
		new Not(
			«compileFormula(not.not)»)'''
	}
	
	private def dispatch String compileFormula(IsEmpty isEmpty) {
		'''
		new IsEmpty(
			«compileTerm(isEmpty.term)»)'''
	}
	
	private def dispatch String compileFormula(Equals equals) {
		'''
		new Equality(
			«compileTerm(equals.left)»,
			«compileTerm(equals.right)»)'''
	}
	
	private def dispatch String compileFormula(Greater greater) {
		'''
		new IsGreater(
			«compileTerm(greater.left)»,
			«compileTerm(greater.right)»)'''
	}
	
	private def dispatch String compileFormula(GreaterEqual greaterEqual) {
		'''
		new IsGreaterEqual(
			«compileTerm(greaterEqual.left)»,
			«compileTerm(greaterEqual.right)»)'''
	}
	
	private def dispatch String compileFormula(Smaller smaller) {
		'''
		new IsSmaller(
			«compileTerm(smaller.left)»,
			«compileTerm(smaller.right)»)'''
	}
	
	private def dispatch String compileFormula(SmallerEqual smallerEqual) {
		'''
		new IsSmallerEqual(
			«compileTerm(smallerEqual.left)»,
			«compileTerm(smallerEqual.right)»)'''
	}

	private def dispatch String compileFormula(IsInstanceOf isInstanceOf) {
		'''
		new IsInstanceOf(
			«compileTerm(isInstanceOf.term)»,
			«compileTerm(isInstanceOf.type)»)'''
	}

	private def dispatch String compileFormula(IsValueLiteralOf isValueLiteralOf) {
		'''
		new IsValueLiteralOf(
			«compileTerm(isValueLiteralOf.term)»,
			«compileTerm(isValueLiteralOf.type)»)'''
	}

	private def dispatch String compileFormula(ForAll forAll) {
		'''
		new ForAll(
			«compileVariable(forAll.name)»,
			«compileTerm(forAll.iteration)»,
			«compileFormula(forAll.formula)»)'''
	}

	private def dispatch String compileFormula(Exists exists) {
		'''
		new Exists(
			«compileVariable(exists.name)»,
			«compileTerm(exists.iteration)»,
			«compileFormula(exists.formula)»)'''
	}
	
	private def dispatch String compileFormula(BoolConstant bool) {
		if (bool.value) {
			'ConstantFormula.TRUE'
		} else {
			'ConstantFormula.FALSE'
		}
	}
	
	private def dispatch String compileTerm(Term term) {
		throw new UnsupportedOperationException('Generator not implemented for term: ' + term)
	}
	
	private def dispatch String compileTerm(IntConstant integer) {
		'''new Constant(«integer.value»)'''
	}
	
	private def dispatch String compileTerm(StringConstant string) {
		'''new Constant("«string.value»")'''
	}
	
	private def dispatch String compileTerm(BoolConstant bool) {
		if (bool.value) {
			'BoolConstant.TRUE'
		} else {
			'BoolConstant.FALSE'
		}
	}
	
	private def dispatch String compileFormula(Void nullArgument) {
		'null' // formula is null
	}



	//////////////////////////////////////////////////////////
	// Terms

	private def dispatch String compileTerm(MetaConstant constant) {
		if(constant.classifier === null) {
			return 'null'
		}
		val literalOrFeature = constant.literalOrFeature
		val constantStringValue = if(literalOrFeature instanceof EEnumLiteral) {
			compileEnumLiteral(literalOrFeature)
		} else if(literalOrFeature instanceof EStructuralFeature) {
			compileFeature(literalOrFeature)
		} else {
			compileType(constant.classifier)
		}

		'''new Constant(«constantStringValue»)'''
	}
	
	private def dispatch String compileTerm(Capitalize capitalize) {
		'''
		new Capitalize(
			«compileTerm(capitalize.string)»)'''
	}
	
	private def dispatch String compileTerm(Concatenate concatenate) {
		'''
		new Concatenate(
			«compileTerm(concatenate.left)»,
			«compileTerm(concatenate.right)»)'''
	}
	
	private def dispatch String compileTerm(GetClosure getClosure) {
		compileGet(
			'''
			new GetClosure(
				«compileTerm(getClosure.initial)»,
				«compileVariable(getClosure.variable)»,
				«compileTerm(getClosure.iteration)»)''',
			getClosure.get)
	}
	
	private def dispatch String compileTerm(GetContainer getContainer) {
		compileGet(
			'''
			new GetContainer(
				«compileTerm(getContainer.element)»)''',
			getContainer.get)
	}
	
	private def dispatch String compileTerm(GetContainments getContainments) {
		compileGet(
			'''
			new GetContainments(
				«compileTerm(getContainments.element)»)''',
			getContainments.get)
	}
	
	private def dispatch String compileTerm(Size size) {
		'''
		new Size(
			«compileTerm(size.elements)»)'''
	}
	
	private def dispatch String compileTerm(IndexOf indexOf) {
		'''
		new IndexOf(
			«compileTerm(indexOf.container)»,
			«compileTerm(indexOf.element)»)'''
	}
	
	private def dispatch String compileTerm(Select select) {
		return compileGet(
			'''
			new Select(
				«compileTerm(select.iteration)»,
				«compileVariable(select.name)»,
				«compileFormula(select.formula)»)''',
			select.get)
	}
	
	private def dispatch String compileTerm(VariableRef varRef) {
		return compileGet(names.get(varRef.name), varRef.get)
	}
	
	private def dispatch String compileTerm(Void nullArgument) {
		'null' // term is null
	}


	private def static void saveAsXMI(Resource resource) {
		val resourceSet = new ResourceSetImpl()
	 	val xmiResource = resourceSet.createResource(resource.URI.trimFileExtension.appendFileExtension("xmi"))
		xmiResource.contents += EcoreUtil2.copy(resource.contents.head)
		xmiResource.save(Collections.emptyMap())
	}
}
