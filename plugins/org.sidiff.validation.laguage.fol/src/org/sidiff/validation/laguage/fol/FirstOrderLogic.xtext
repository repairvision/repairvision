grammar org.sidiff.validation.laguage.fol.FirstOrderLogic with org.eclipse.xtext.common.Terminals

generate firstOrderLogic "http://www.sidiff.org/validation/laguage/fol/FirstOrderLogic"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// NOTES: 
// - escape keywords with ^keyword
// - http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/

ConstraintLibrary:
	imports+=Import*
	constraints+=Constraint*;

Import:
	'domain' domain=STRING;
	
Constraint:
	'constraint' name=ID 'message' message=STRING 'context' variable=Variable ('<' type=[ecore::EClassifier] '>')?':' formula=Formula;

Variable:
	type=[ecore::EClassifier] name=ID;

// formula:

/* 
 * Precedence: not, and, or, xor, if/implies, iff
 * 
 * To define the precedence we must write the rule for the operator with less precedence in 
 * terms of the rule for the operator with higher precedence. This means that in the grammar, 
 * the rules for operators with less precedence are defined first.
 */
 
// binary formulas:

Formula:
	BinaryFormula;
	
BinaryFormula returns Formula:
	Iff;
	
Iff returns Formula:
	If ({Iff.left=current} "=" right=If)*;

If returns Formula:
	Xor ({If.left=current} "implies" right=Xor)*;

Xor returns Formula:
	Or ({Xor.left=current} "xor" right=Or)*;

Or returns Formula:
	And ({Or.left=current} "or" right=And)*;

And returns Formula:
	BooleanExpression ({And.left=current} "and" right=BooleanExpression)*;

// unary formulas:

UnaryFormula returns Formula :
	Not;

Not returns UnaryFormula:
	{Not} "not" "(" not=Formula ")";
	
// predicates (term -> boolean):

Predicate returns Formula:
	Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf;

Equals:
	"isEqual" "(" (left=Term) "," (right=Term) ")";

Inequality returns Formula:
	Greater | GreaterEqual | Smaller | SmallerEqual;

Greater:
	"isGreater" "(" (left=Term) "," (right=Term) ")";
	
GreaterEqual:
	"isGreaterEqual" "(" (left=Term) "," (right=Term) ")";
	
Smaller:
	"isSmaller" "(" (left=Term) "," (right=Term) ")";
	
SmallerEqual:
	"isSmallerEqual" "(" (left=Term) "," (right=Term) ")";	
	
IsEmpty:
	"isEmpty" "(" term=Term ")";
	
IsInstanceOf:
	"isInstanceOf" "(" term=Term "," type=Term ")";
	
IsValueLiteralOf:
	"isValueLiteralOf" "(" term=Term "," type=Term ")";

// quantifier

Quantifier returns Formula:
	ForAll | Exists;

ForAll returns Quantifier:
	{ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	
Exists returns Quantifier:
	{Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";

// boolean:

BooleanExpression returns Formula:
	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant;

// terms:

Term:
	ReferenceBase
		| Concatenate
		| Size | IndexOf | Capitalize
		| Constant;

// Base class for Rules that support navigation using Get.
ReferenceBase:
	(VariableRef | Select | GetContainer | GetContainments | GetClosure) (get=Get)?;
	
// A reference to a Variable, which can be navigated using Get.
VariableRef:
	name=[Variable];

// Select evaluates to all possible Variable assignments
// bound by the given Term, which satisfy the given formula.
// The result can be navigated using Get.
Select:
	"select" "(" iteration=Term "," name=Variable ":" formula=Formula ")";

// function terms (term -> term):

Get:
	"." (type=[ecore::EClass] "::" )? name=[ecore::EStructuralFeature] (next=Get)?;
	
GetContainer:
	"getContainer" "(" element=Term ")";
	
GetContainments:
	"getContainments" "(" element=Term ")";
	
GetClosure:
	"getClosure" "(" initial=Term "," variable=Variable ":" iteration=Term ")";
	
Size: 
	"size" "(" elements=Term ")";
	
IndexOf:
	"indexOf" "(" container=Term "," element=Term ")";
	
Concatenate :
	"concatenate" "(" left=Term "," right=Term ")";
	
Capitalize :
	"capitalize" "(" string=Term ")";

// primitive terms:

Constant returns Term:
	IntConstant | StringConstant | BoolConstant | MetaConstant;

IntConstant:
	value=SIGNED_INT;

StringConstant:
	value=STRING;

BoolConstant:
	value=BOOLEAN;

// If classifier is an EClass, literalOrFeature may be an EStructuralFeature of that class.
// If classifier is an EEnum, literalOrFeature may be an EEnumLiteral of that enum.
// Else, literalOrValue is not set.
MetaConstant:
	classifier=[ecore::EClassifier] ("::" literalOrFeature=[ecore::ENamedElement])?;


// terminals:

terminal BOOLEAN returns ecore::EBoolean:
	'true'|'false';
	
terminal SIGNED_INT returns ecore::EInt:
	'-'? INT;