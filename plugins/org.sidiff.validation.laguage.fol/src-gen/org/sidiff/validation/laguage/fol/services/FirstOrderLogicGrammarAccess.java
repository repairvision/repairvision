/*
 * generated by Xtext 2.21.0
 */
package org.sidiff.validation.laguage.fol.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FirstOrderLogicGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ConstraintLibraryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ConstraintLibrary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsConstraintParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//// NOTES: 
		//// - escape keywords with ^keyword
		//// - http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
		//ConstraintLibrary:
		//	imports+=Import*
		//	constraints+=Constraint*;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+=Import* constraints+=Constraint*
		public Group getGroup() { return cGroup; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_1_0() { return cConstraintsConstraintParserRuleCall_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDomainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDomainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDomainSTRINGTerminalRuleCall_1_0 = (RuleCall)cDomainAssignment_1.eContents().get(0);
		
		//Import:
		//	'domain' domain=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'domain' domain=STRING
		public Group getGroup() { return cGroup; }
		
		//'domain'
		public Keyword getDomainKeyword_0() { return cDomainKeyword_0; }
		
		//domain=STRING
		public Assignment getDomainAssignment_1() { return cDomainAssignment_1; }
		
		//STRING
		public RuleCall getDomainSTRINGTerminalRuleCall_1_0() { return cDomainSTRINGTerminalRuleCall_1_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cMessageKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMessageSTRINGTerminalRuleCall_3_0 = (RuleCall)cMessageAssignment_3.eContents().get(0);
		private final Keyword cContextKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cVariableVariableParserRuleCall_5_0 = (RuleCall)cVariableAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cLessThanSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cTypeAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final CrossReference cTypeEClassifierCrossReference_6_1_0 = (CrossReference)cTypeAssignment_6_1.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_6_1_0_1 = (RuleCall)cTypeEClassifierCrossReference_6_1_0.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Keyword cColonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cFormulaAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cFormulaFormulaParserRuleCall_8_0 = (RuleCall)cFormulaAssignment_8.eContents().get(0);
		
		//Constraint:
		//	'constraint' name=ID 'message' message=STRING 'context' variable=Variable ('<' type=[ecore::EClassifier] '>')? ':'
		//	formula=Formula;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraint' name=ID 'message' message=STRING 'context' variable=Variable ('<' type=[ecore::EClassifier] '>')? ':'
		//formula=Formula
		public Group getGroup() { return cGroup; }
		
		//'constraint'
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'message'
		public Keyword getMessageKeyword_2() { return cMessageKeyword_2; }
		
		//message=STRING
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }
		
		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_3_0() { return cMessageSTRINGTerminalRuleCall_3_0; }
		
		//'context'
		public Keyword getContextKeyword_4() { return cContextKeyword_4; }
		
		//variable=Variable
		public Assignment getVariableAssignment_5() { return cVariableAssignment_5; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_5_0() { return cVariableVariableParserRuleCall_5_0; }
		
		//('<' type=[ecore::EClassifier] '>')?
		public Group getGroup_6() { return cGroup_6; }
		
		//'<'
		public Keyword getLessThanSignKeyword_6_0() { return cLessThanSignKeyword_6_0; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_6_1() { return cTypeAssignment_6_1; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_6_1_0() { return cTypeEClassifierCrossReference_6_1_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_6_1_0_1() { return cTypeEClassifierIDTerminalRuleCall_6_1_0_1; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_6_2() { return cGreaterThanSignKeyword_6_2; }
		
		//':'
		public Keyword getColonKeyword_7() { return cColonKeyword_7; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_8() { return cFormulaAssignment_8; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_8_0() { return cFormulaFormulaParserRuleCall_8_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Variable:
		//	type=[ecore::EClassifier] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClassifier] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_0_0() { return cTypeEClassifierCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Formula");
		private final RuleCall cBinaryFormulaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// formula:
		///* 
		// * Precedence: not, and, or, xor, if/implies, iff
		// * 
		// * To define the precedence we must write the rule for the operator with less precedence in 
		// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
		// * the rules for operators with less precedence are defined first.
		// */ // binary formulas:
		//Formula:
		//	BinaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//BinaryFormula
		public RuleCall getBinaryFormulaParserRuleCall() { return cBinaryFormulaParserRuleCall; }
	}
	public class BinaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BinaryFormula");
		private final RuleCall cIffParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BinaryFormula Formula:
		//	Iff;
		@Override public ParserRule getRule() { return rule; }
		
		//Iff
		public RuleCall getIffParserRuleCall() { return cIffParserRuleCall; }
	}
	public class IffElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Iff");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIfParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIffLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIfParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Iff Formula:
		//	If ({Iff.left=current} "=" right=If)*;
		@Override public ParserRule getRule() { return rule; }
		
		//If ({Iff.left=current} "=" right=If)*
		public Group getGroup() { return cGroup; }
		
		//If
		public RuleCall getIfParserRuleCall_0() { return cIfParserRuleCall_0; }
		
		//({Iff.left=current} "=" right=If)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Iff.left=current}
		public Action getIffLeftAction_1_0() { return cIffLeftAction_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//right=If
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//If
		public RuleCall getRightIfParserRuleCall_1_2_0() { return cRightIfParserRuleCall_1_2_0; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//If Formula:
		//	Xor ({If.left=current} "implies" right=Xor)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({If.left=current} "implies" right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({If.left=current} "implies" right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{If.left=current}
		public Action getIfLeftAction_1_0() { return cIfLeftAction_1_0; }
		
		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cXorKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor Formula:
		//	Or ({Xor.left=current} "xor" right=Or)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Xor.left=current} "xor" right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Xor.left=current} "xor" right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//"xor"
		public Keyword getXorKeyword_1_1() { return cXorKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Formula:
		//	And ({Or.left=current} "or" right=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} "or" right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} "or" right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Formula:
		//	BooleanExpression ({And.left=current} "and" right=BooleanExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanExpression ({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup() { return cGroup; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_0() { return cBooleanExpressionParserRuleCall_0; }
		
		//({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=BooleanExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BooleanExpression
		public RuleCall getRightBooleanExpressionParserRuleCall_1_2_0() { return cRightBooleanExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.UnaryFormula");
		private final RuleCall cNotParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// unary formulas:
		//UnaryFormula Formula:
		//	Not;
		@Override public ParserRule getRule() { return rule; }
		
		//Not
		public RuleCall getNotParserRuleCall() { return cNotParserRuleCall; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNotAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNotFormulaParserRuleCall_3_0 = (RuleCall)cNotAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Not UnaryFormula:
		//	{Not} "not" "(" not=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{Not} "not" "(" not=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }
		
		//"not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//not=Formula
		public Assignment getNotAssignment_3() { return cNotAssignment_3; }
		
		//Formula
		public RuleCall getNotFormulaParserRuleCall_3_0() { return cNotFormulaParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Predicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEqualsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInequalityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIsEmptyParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIsInstanceOfParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIsValueLiteralOfParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// predicates (term -> boolean):
		//Predicate Formula:
		//	Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf;
		@Override public ParserRule getRule() { return rule; }
		
		//Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Equals
		public RuleCall getEqualsParserRuleCall_0() { return cEqualsParserRuleCall_0; }
		
		//Inequality
		public RuleCall getInequalityParserRuleCall_1() { return cInequalityParserRuleCall_1; }
		
		//IsEmpty
		public RuleCall getIsEmptyParserRuleCall_2() { return cIsEmptyParserRuleCall_2; }
		
		//IsInstanceOf
		public RuleCall getIsInstanceOfParserRuleCall_3() { return cIsInstanceOfParserRuleCall_3; }
		
		//IsValueLiteralOf
		public RuleCall getIsValueLiteralOfParserRuleCall_4() { return cIsValueLiteralOfParserRuleCall_4; }
	}
	public class EqualsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Equals");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Equals:
		//	"isEqual" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEqual" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isEqual"
		public Keyword getIsEqualKeyword_0() { return cIsEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class InequalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Inequality");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGreaterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGreaterEqualParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSmallerParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSmallerEqualParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Inequality Formula:
		//	Greater | GreaterEqual | Smaller | SmallerEqual;
		@Override public ParserRule getRule() { return rule; }
		
		//Greater | GreaterEqual | Smaller | SmallerEqual
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Greater
		public RuleCall getGreaterParserRuleCall_0() { return cGreaterParserRuleCall_0; }
		
		//GreaterEqual
		public RuleCall getGreaterEqualParserRuleCall_1() { return cGreaterEqualParserRuleCall_1; }
		
		//Smaller
		public RuleCall getSmallerParserRuleCall_2() { return cSmallerParserRuleCall_2; }
		
		//SmallerEqual
		public RuleCall getSmallerEqualParserRuleCall_3() { return cSmallerEqualParserRuleCall_3; }
	}
	public class GreaterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Greater");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Greater:
		//	"isGreater" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreater" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreater"
		public Keyword getIsGreaterKeyword_0() { return cIsGreaterKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class GreaterEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GreaterEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//GreaterEqual:
		//	"isGreaterEqual" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreaterEqual" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreaterEqual"
		public Keyword getIsGreaterEqualKeyword_0() { return cIsGreaterEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class SmallerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Smaller");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Smaller:
		//	"isSmaller" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmaller" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmaller"
		public Keyword getIsSmallerKeyword_0() { return cIsSmallerKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class SmallerEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SmallerEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SmallerEqual:
		//	"isSmallerEqual" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmallerEqual" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmallerEqual"
		public Keyword getIsSmallerEqualKeyword_0() { return cIsSmallerEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class IsEmptyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsEmpty");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEmptyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//IsEmpty:
		//	"isEmpty" "(" term=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEmpty" "(" term=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isEmpty"
		public Keyword getIsEmptyKeyword_0() { return cIsEmptyKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class IsInstanceOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsInstanceOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsInstanceOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeTermParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IsInstanceOf:
		//	"isInstanceOf" "(" term=Term "," type=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isInstanceOf" "(" term=Term "," type=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isInstanceOf"
		public Keyword getIsInstanceOfKeyword_0() { return cIsInstanceOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//type=Term
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//Term
		public RuleCall getTypeTermParserRuleCall_4_0() { return cTypeTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class IsValueLiteralOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsValueLiteralOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsValueLiteralOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeTermParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IsValueLiteralOf:
		//	"isValueLiteralOf" "(" term=Term "," type=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isValueLiteralOf" "(" term=Term "," type=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isValueLiteralOf"
		public Keyword getIsValueLiteralOfKeyword_0() { return cIsValueLiteralOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//type=Term
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//Term
		public RuleCall getTypeTermParserRuleCall_4_0() { return cTypeTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForAllParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// quantifier
		//Quantifier Formula:
		//	ForAll | Exists;
		@Override public ParserRule getRule() { return rule; }
		
		//ForAll | Exists
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForAll
		public RuleCall getForAllParserRuleCall_0() { return cForAllParserRuleCall_0; }
		
		//Exists
		public RuleCall getExistsParserRuleCall_1() { return cExistsParserRuleCall_1; }
	}
	public class ForAllElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ForAll");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForAllAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForAllKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameVariableParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIterationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIterationTermParserRuleCall_5_0 = (RuleCall)cIterationAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//ForAll Quantifier:
		//	{ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{ForAll}
		public Action getForAllAction_0() { return cForAllAction_0; }
		
		//"forAll"
		public Keyword getForAllKeyword_1() { return cForAllKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=Variable
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_3_0() { return cNameVariableParserRuleCall_3_0; }
		
		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//iteration=Term
		public Assignment getIterationAssignment_5() { return cIterationAssignment_5; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_5_0() { return cIterationTermParserRuleCall_5_0; }
		
		//":"
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
	}
	public class ExistsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Exists");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameVariableParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIterationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIterationTermParserRuleCall_5_0 = (RuleCall)cIterationAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Exists Quantifier:
		//	{Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Exists}
		public Action getExistsAction_0() { return cExistsAction_0; }
		
		//"exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=Variable
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_3_0() { return cNameVariableParserRuleCall_3_0; }
		
		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//iteration=Term
		public Assignment getIterationAssignment_5() { return cIterationAssignment_5; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_5_0() { return cIterationTermParserRuleCall_5_0; }
		
		//":"
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BooleanExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cFormulaParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cUnaryFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPredicateParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBoolConstantParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// boolean:
		//BooleanExpression Formula:
		//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Formula ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_0_1() { return cFormulaParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//UnaryFormula
		public RuleCall getUnaryFormulaParserRuleCall_1() { return cUnaryFormulaParserRuleCall_1; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_2() { return cQuantifierParserRuleCall_2; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_3() { return cPredicateParserRuleCall_3; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_4() { return cBoolConstantParserRuleCall_4; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReferenceBaseParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConcatenateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSizeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIndexOfParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCapitalizeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cConstantParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//// terms:
		//Term:
		//	ReferenceBase
		//	| Concatenate
		//	| Size | IndexOf | Capitalize
		//	| Constant;
		@Override public ParserRule getRule() { return rule; }
		
		//ReferenceBase | Concatenate | Size | IndexOf | Capitalize | Constant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ReferenceBase
		public RuleCall getReferenceBaseParserRuleCall_0() { return cReferenceBaseParserRuleCall_0; }
		
		//Concatenate
		public RuleCall getConcatenateParserRuleCall_1() { return cConcatenateParserRuleCall_1; }
		
		//Size
		public RuleCall getSizeParserRuleCall_2() { return cSizeParserRuleCall_2; }
		
		//IndexOf
		public RuleCall getIndexOfParserRuleCall_3() { return cIndexOfParserRuleCall_3; }
		
		//Capitalize
		public RuleCall getCapitalizeParserRuleCall_4() { return cCapitalizeParserRuleCall_4; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_5() { return cConstantParserRuleCall_5; }
	}
	public class ReferenceBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ReferenceBase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cVariableRefParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cSelectParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cGetContainerParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cGetContainmentsParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final RuleCall cGetClosureParserRuleCall_0_4 = (RuleCall)cAlternatives_0.eContents().get(4);
		private final Assignment cGetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGetGetParserRuleCall_1_0 = (RuleCall)cGetAssignment_1.eContents().get(0);
		
		//// Base class for Rules that support navigation using Get.
		//ReferenceBase:
		//	(VariableRef | Select | GetContainer | GetContainments | GetClosure) get=Get?;
		@Override public ParserRule getRule() { return rule; }
		
		//(VariableRef | Select | GetContainer | GetContainments | GetClosure) get=Get?
		public Group getGroup() { return cGroup; }
		
		//(VariableRef | Select | GetContainer | GetContainments | GetClosure)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//VariableRef
		public RuleCall getVariableRefParserRuleCall_0_0() { return cVariableRefParserRuleCall_0_0; }
		
		//Select
		public RuleCall getSelectParserRuleCall_0_1() { return cSelectParserRuleCall_0_1; }
		
		//GetContainer
		public RuleCall getGetContainerParserRuleCall_0_2() { return cGetContainerParserRuleCall_0_2; }
		
		//GetContainments
		public RuleCall getGetContainmentsParserRuleCall_0_3() { return cGetContainmentsParserRuleCall_0_3; }
		
		//GetClosure
		public RuleCall getGetClosureParserRuleCall_0_4() { return cGetClosureParserRuleCall_0_4; }
		
		//get=Get?
		public Assignment getGetAssignment_1() { return cGetAssignment_1; }
		
		//Get
		public RuleCall getGetGetParserRuleCall_1_0() { return cGetGetParserRuleCall_1_0; }
	}
	public class VariableRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.VariableRef");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cNameVariableCrossReference_0 = (CrossReference)cNameAssignment.eContents().get(0);
		private final RuleCall cNameVariableIDTerminalRuleCall_0_1 = (RuleCall)cNameVariableCrossReference_0.eContents().get(1);
		
		//// A reference to a Variable, which can be navigated using Get.
		//VariableRef:
		//	name=[Variable];
		@Override public ParserRule getRule() { return rule; }
		
		//name=[Variable]
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//[Variable]
		public CrossReference getNameVariableCrossReference_0() { return cNameVariableCrossReference_0; }
		
		//ID
		public RuleCall getNameVariableIDTerminalRuleCall_0_1() { return cNameVariableIDTerminalRuleCall_0_1; }
	}
	public class SelectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Select");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIterationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIterationTermParserRuleCall_2_0 = (RuleCall)cIterationAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameVariableParserRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFormulaFormulaParserRuleCall_6_0 = (RuleCall)cFormulaAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// Select evaluates to all possible Variable assignments
		//// bound by the given Term, which satisfy the given formula.
		//// The result can be navigated using Get.
		//Select:
		//	"select" "(" iteration=Term "," name=Variable ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"select" "(" iteration=Term "," name=Variable ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//"select"
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//iteration=Term
		public Assignment getIterationAssignment_2() { return cIterationAssignment_2; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_2_0() { return cIterationTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//name=Variable
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_4_0() { return cNameVariableParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_6() { return cFormulaAssignment_6; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_6_0() { return cFormulaFormulaParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class GetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Get");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cTypeEClassCrossReference_1_0_0 = (CrossReference)cTypeAssignment_1_0.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_1_0_0_1 = (RuleCall)cTypeEClassCrossReference_1_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNameEStructuralFeatureCrossReference_2_0 = (CrossReference)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameEStructuralFeatureIDTerminalRuleCall_2_0_1 = (RuleCall)cNameEStructuralFeatureCrossReference_2_0.eContents().get(1);
		private final Assignment cNextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNextGetParserRuleCall_3_0 = (RuleCall)cNextAssignment_3.eContents().get(0);
		
		//// function terms (term -> term):
		//Get:
		//	"." (type=[ecore::EClass] "::")? name=[ecore::EStructuralFeature] next=Get?;
		@Override public ParserRule getRule() { return rule; }
		
		//"." (type=[ecore::EClass] "::")? name=[ecore::EStructuralFeature] next=Get?
		public Group getGroup() { return cGroup; }
		
		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//(type=[ecore::EClass] "::")?
		public Group getGroup_1() { return cGroup_1; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_1_0_0() { return cTypeEClassCrossReference_1_0_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_1_0_0_1() { return cTypeEClassIDTerminalRuleCall_1_0_0_1; }
		
		//"::"
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//name=[ecore::EStructuralFeature]
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//[ecore::EStructuralFeature]
		public CrossReference getNameEStructuralFeatureCrossReference_2_0() { return cNameEStructuralFeatureCrossReference_2_0; }
		
		//ID
		public RuleCall getNameEStructuralFeatureIDTerminalRuleCall_2_0_1() { return cNameEStructuralFeatureIDTerminalRuleCall_2_0_1; }
		
		//next=Get?
		public Assignment getNextAssignment_3() { return cNextAssignment_3; }
		
		//Get
		public RuleCall getNextGetParserRuleCall_3_0() { return cNextGetParserRuleCall_3_0; }
	}
	public class GetContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementTermParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GetContainer:
		//	"getContainer" "(" element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainer" "(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainer"
		public Keyword getGetContainerKeyword_0() { return cGetContainerKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//element=Term
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_2_0() { return cElementTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class GetContainmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainmentsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementTermParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GetContainments:
		//	"getContainments" "(" element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainments" "(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainments"
		public Keyword getGetContainmentsKeyword_0() { return cGetContainmentsKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//element=Term
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_2_0() { return cElementTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class GetClosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetClosure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetClosureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitialAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitialTermParserRuleCall_2_0 = (RuleCall)cInitialAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVariableAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVariableVariableParserRuleCall_4_0 = (RuleCall)cVariableAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cIterationAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cIterationTermParserRuleCall_6_0 = (RuleCall)cIterationAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//GetClosure:
		//	"getClosure" "(" initial=Term "," variable=Variable ":" iteration=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getClosure" "(" initial=Term "," variable=Variable ":" iteration=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getClosure"
		public Keyword getGetClosureKeyword_0() { return cGetClosureKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//initial=Term
		public Assignment getInitialAssignment_2() { return cInitialAssignment_2; }
		
		//Term
		public RuleCall getInitialTermParserRuleCall_2_0() { return cInitialTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//variable=Variable
		public Assignment getVariableAssignment_4() { return cVariableAssignment_4; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_4_0() { return cVariableVariableParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//iteration=Term
		public Assignment getIterationAssignment_6() { return cIterationAssignment_6; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_6_0() { return cIterationTermParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class SizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Size");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementsTermParserRuleCall_2_0 = (RuleCall)cElementsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Size:
		//	"size" "(" elements=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"size" "(" elements=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"size"
		public Keyword getSizeKeyword_0() { return cSizeKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//elements=Term
		public Assignment getElementsAssignment_2() { return cElementsAssignment_2; }
		
		//Term
		public RuleCall getElementsTermParserRuleCall_2_0() { return cElementsTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class IndexOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IndexOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIndexOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cContainerAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContainerTermParserRuleCall_2_0 = (RuleCall)cContainerAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cElementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElementTermParserRuleCall_4_0 = (RuleCall)cElementAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IndexOf:
		//	"indexOf" "(" container=Term "," element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"indexOf" "(" container=Term "," element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"indexOf"
		public Keyword getIndexOfKeyword_0() { return cIndexOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//container=Term
		public Assignment getContainerAssignment_2() { return cContainerAssignment_2; }
		
		//Term
		public RuleCall getContainerTermParserRuleCall_2_0() { return cContainerTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//element=Term
		public Assignment getElementAssignment_4() { return cElementAssignment_4; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_4_0() { return cElementTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class ConcatenateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Concatenate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConcatenateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Concatenate:
		//	"concatenate" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"concatenate" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"concatenate"
		public Keyword getConcatenateKeyword_0() { return cConcatenateKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class CapitalizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Capitalize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCapitalizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStringAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStringTermParserRuleCall_2_0 = (RuleCall)cStringAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Capitalize:
		//	"capitalize" "(" string=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"capitalize" "(" string=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"capitalize"
		public Keyword getCapitalizeKeyword_0() { return cCapitalizeKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//string=Term
		public Assignment getStringAssignment_2() { return cStringAssignment_2; }
		
		//Term
		public RuleCall getStringTermParserRuleCall_2_0() { return cStringTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBoolConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMetaConstantParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// primitive terms:
		//Constant Term:
		//	IntConstant | StringConstant | BoolConstant | MetaConstant;
		@Override public ParserRule getRule() { return rule; }
		
		//IntConstant | StringConstant | BoolConstant | MetaConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntConstant
		public RuleCall getIntConstantParserRuleCall_0() { return cIntConstantParserRuleCall_0; }
		
		//StringConstant
		public RuleCall getStringConstantParserRuleCall_1() { return cStringConstantParserRuleCall_1; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_2() { return cBoolConstantParserRuleCall_2; }
		
		//MetaConstant
		public RuleCall getMetaConstantParserRuleCall_3() { return cMetaConstantParserRuleCall_3; }
	}
	public class IntConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IntConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSIGNED_INTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntConstant:
		//	value=SIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=SIGNED_INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//SIGNED_INT
		public RuleCall getValueSIGNED_INTTerminalRuleCall_0() { return cValueSIGNED_INTTerminalRuleCall_0; }
	}
	public class StringConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.StringConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringConstant:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class BoolConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BoolConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BoolConstant:
		//	value=BOOLEAN;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}
	public class MetaConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.MetaConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClassifierEClassifierCrossReference_1_0 = (CrossReference)cClassifierAssignment_1.eContents().get(0);
		private final RuleCall cClassifierEClassifierIDTerminalRuleCall_1_0_1 = (RuleCall)cClassifierEClassifierCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLiteralOrFeatureAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cLiteralOrFeatureENamedElementCrossReference_2_1_0 = (CrossReference)cLiteralOrFeatureAssignment_2_1.eContents().get(0);
		private final RuleCall cLiteralOrFeatureENamedElementIDTerminalRuleCall_2_1_0_1 = (RuleCall)cLiteralOrFeatureENamedElementCrossReference_2_1_0.eContents().get(1);
		
		//// If classifier is an EClass, literalOrFeature may be an EStructuralFeature of that class.
		//// If classifier is an EEnum, literalOrFeature may be an EEnumLiteral of that enum.
		//// Else, literalOrValue is not set.
		//MetaConstant:
		//	"$" classifier=[ecore::EClassifier] ("::" literalOrFeature=[ecore::ENamedElement])?;
		@Override public ParserRule getRule() { return rule; }
		
		//"$" classifier=[ecore::EClassifier] ("::" literalOrFeature=[ecore::ENamedElement])?
		public Group getGroup() { return cGroup; }
		
		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }
		
		//classifier=[ecore::EClassifier]
		public Assignment getClassifierAssignment_1() { return cClassifierAssignment_1; }
		
		//[ecore::EClassifier]
		public CrossReference getClassifierEClassifierCrossReference_1_0() { return cClassifierEClassifierCrossReference_1_0; }
		
		//ID
		public RuleCall getClassifierEClassifierIDTerminalRuleCall_1_0_1() { return cClassifierEClassifierIDTerminalRuleCall_1_0_1; }
		
		//("::" literalOrFeature=[ecore::ENamedElement])?
		public Group getGroup_2() { return cGroup_2; }
		
		//"::"
		public Keyword getColonColonKeyword_2_0() { return cColonColonKeyword_2_0; }
		
		//literalOrFeature=[ecore::ENamedElement]
		public Assignment getLiteralOrFeatureAssignment_2_1() { return cLiteralOrFeatureAssignment_2_1; }
		
		//[ecore::ENamedElement]
		public CrossReference getLiteralOrFeatureENamedElementCrossReference_2_1_0() { return cLiteralOrFeatureENamedElementCrossReference_2_1_0; }
		
		//ID
		public RuleCall getLiteralOrFeatureENamedElementIDTerminalRuleCall_2_1_0_1() { return cLiteralOrFeatureENamedElementIDTerminalRuleCall_2_1_0_1; }
	}
	
	
	private final ConstraintLibraryElements pConstraintLibrary;
	private final ImportElements pImport;
	private final ConstraintElements pConstraint;
	private final VariableElements pVariable;
	private final FormulaElements pFormula;
	private final BinaryFormulaElements pBinaryFormula;
	private final IffElements pIff;
	private final IfElements pIf;
	private final XorElements pXor;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final UnaryFormulaElements pUnaryFormula;
	private final NotElements pNot;
	private final PredicateElements pPredicate;
	private final EqualsElements pEquals;
	private final InequalityElements pInequality;
	private final GreaterElements pGreater;
	private final GreaterEqualElements pGreaterEqual;
	private final SmallerElements pSmaller;
	private final SmallerEqualElements pSmallerEqual;
	private final IsEmptyElements pIsEmpty;
	private final IsInstanceOfElements pIsInstanceOf;
	private final IsValueLiteralOfElements pIsValueLiteralOf;
	private final QuantifierElements pQuantifier;
	private final ForAllElements pForAll;
	private final ExistsElements pExists;
	private final BooleanExpressionElements pBooleanExpression;
	private final TermElements pTerm;
	private final ReferenceBaseElements pReferenceBase;
	private final VariableRefElements pVariableRef;
	private final SelectElements pSelect;
	private final GetElements pGet;
	private final GetContainerElements pGetContainer;
	private final GetContainmentsElements pGetContainments;
	private final GetClosureElements pGetClosure;
	private final SizeElements pSize;
	private final IndexOfElements pIndexOf;
	private final ConcatenateElements pConcatenate;
	private final CapitalizeElements pCapitalize;
	private final ConstantElements pConstant;
	private final IntConstantElements pIntConstant;
	private final StringConstantElements pStringConstant;
	private final BoolConstantElements pBoolConstant;
	private final MetaConstantElements pMetaConstant;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tSIGNED_INT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FirstOrderLogicGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pConstraintLibrary = new ConstraintLibraryElements();
		this.pImport = new ImportElements();
		this.pConstraint = new ConstraintElements();
		this.pVariable = new VariableElements();
		this.pFormula = new FormulaElements();
		this.pBinaryFormula = new BinaryFormulaElements();
		this.pIff = new IffElements();
		this.pIf = new IfElements();
		this.pXor = new XorElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pUnaryFormula = new UnaryFormulaElements();
		this.pNot = new NotElements();
		this.pPredicate = new PredicateElements();
		this.pEquals = new EqualsElements();
		this.pInequality = new InequalityElements();
		this.pGreater = new GreaterElements();
		this.pGreaterEqual = new GreaterEqualElements();
		this.pSmaller = new SmallerElements();
		this.pSmallerEqual = new SmallerEqualElements();
		this.pIsEmpty = new IsEmptyElements();
		this.pIsInstanceOf = new IsInstanceOfElements();
		this.pIsValueLiteralOf = new IsValueLiteralOfElements();
		this.pQuantifier = new QuantifierElements();
		this.pForAll = new ForAllElements();
		this.pExists = new ExistsElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pTerm = new TermElements();
		this.pReferenceBase = new ReferenceBaseElements();
		this.pVariableRef = new VariableRefElements();
		this.pSelect = new SelectElements();
		this.pGet = new GetElements();
		this.pGetContainer = new GetContainerElements();
		this.pGetContainments = new GetContainmentsElements();
		this.pGetClosure = new GetClosureElements();
		this.pSize = new SizeElements();
		this.pIndexOf = new IndexOfElements();
		this.pConcatenate = new ConcatenateElements();
		this.pCapitalize = new CapitalizeElements();
		this.pConstant = new ConstantElements();
		this.pIntConstant = new IntConstantElements();
		this.pStringConstant = new StringConstantElements();
		this.pBoolConstant = new BoolConstantElements();
		this.pMetaConstant = new MetaConstantElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BOOLEAN");
		this.tSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SIGNED_INT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.sidiff.validation.laguage.fol.FirstOrderLogic".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// NOTES: 
	//// - escape keywords with ^keyword
	//// - http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
	//ConstraintLibrary:
	//	imports+=Import*
	//	constraints+=Constraint*;
	public ConstraintLibraryElements getConstraintLibraryAccess() {
		return pConstraintLibrary;
	}
	
	public ParserRule getConstraintLibraryRule() {
		return getConstraintLibraryAccess().getRule();
	}
	
	//Import:
	//	'domain' domain=STRING;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Constraint:
	//	'constraint' name=ID 'message' message=STRING 'context' variable=Variable ('<' type=[ecore::EClassifier] '>')? ':'
	//	formula=Formula;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//Variable:
	//	type=[ecore::EClassifier] name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//// formula:
	///* 
	// * Precedence: not, and, or, xor, if/implies, iff
	// * 
	// * To define the precedence we must write the rule for the operator with less precedence in 
	// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
	// * the rules for operators with less precedence are defined first.
	// */ // binary formulas:
	//Formula:
	//	BinaryFormula;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//BinaryFormula Formula:
	//	Iff;
	public BinaryFormulaElements getBinaryFormulaAccess() {
		return pBinaryFormula;
	}
	
	public ParserRule getBinaryFormulaRule() {
		return getBinaryFormulaAccess().getRule();
	}
	
	//Iff Formula:
	//	If ({Iff.left=current} "=" right=If)*;
	public IffElements getIffAccess() {
		return pIff;
	}
	
	public ParserRule getIffRule() {
		return getIffAccess().getRule();
	}
	
	//If Formula:
	//	Xor ({If.left=current} "implies" right=Xor)*;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//Xor Formula:
	//	Or ({Xor.left=current} "xor" right=Or)*;
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Or Formula:
	//	And ({Or.left=current} "or" right=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Formula:
	//	BooleanExpression ({And.left=current} "and" right=BooleanExpression)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//// unary formulas:
	//UnaryFormula Formula:
	//	Not;
	public UnaryFormulaElements getUnaryFormulaAccess() {
		return pUnaryFormula;
	}
	
	public ParserRule getUnaryFormulaRule() {
		return getUnaryFormulaAccess().getRule();
	}
	
	//Not UnaryFormula:
	//	{Not} "not" "(" not=Formula ")";
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//// predicates (term -> boolean):
	//Predicate Formula:
	//	Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf;
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//Equals:
	//	"isEqual" "(" left=Term "," right=Term ")";
	public EqualsElements getEqualsAccess() {
		return pEquals;
	}
	
	public ParserRule getEqualsRule() {
		return getEqualsAccess().getRule();
	}
	
	//Inequality Formula:
	//	Greater | GreaterEqual | Smaller | SmallerEqual;
	public InequalityElements getInequalityAccess() {
		return pInequality;
	}
	
	public ParserRule getInequalityRule() {
		return getInequalityAccess().getRule();
	}
	
	//Greater:
	//	"isGreater" "(" left=Term "," right=Term ")";
	public GreaterElements getGreaterAccess() {
		return pGreater;
	}
	
	public ParserRule getGreaterRule() {
		return getGreaterAccess().getRule();
	}
	
	//GreaterEqual:
	//	"isGreaterEqual" "(" left=Term "," right=Term ")";
	public GreaterEqualElements getGreaterEqualAccess() {
		return pGreaterEqual;
	}
	
	public ParserRule getGreaterEqualRule() {
		return getGreaterEqualAccess().getRule();
	}
	
	//Smaller:
	//	"isSmaller" "(" left=Term "," right=Term ")";
	public SmallerElements getSmallerAccess() {
		return pSmaller;
	}
	
	public ParserRule getSmallerRule() {
		return getSmallerAccess().getRule();
	}
	
	//SmallerEqual:
	//	"isSmallerEqual" "(" left=Term "," right=Term ")";
	public SmallerEqualElements getSmallerEqualAccess() {
		return pSmallerEqual;
	}
	
	public ParserRule getSmallerEqualRule() {
		return getSmallerEqualAccess().getRule();
	}
	
	//IsEmpty:
	//	"isEmpty" "(" term=Term ")";
	public IsEmptyElements getIsEmptyAccess() {
		return pIsEmpty;
	}
	
	public ParserRule getIsEmptyRule() {
		return getIsEmptyAccess().getRule();
	}
	
	//IsInstanceOf:
	//	"isInstanceOf" "(" term=Term "," type=Term ")";
	public IsInstanceOfElements getIsInstanceOfAccess() {
		return pIsInstanceOf;
	}
	
	public ParserRule getIsInstanceOfRule() {
		return getIsInstanceOfAccess().getRule();
	}
	
	//IsValueLiteralOf:
	//	"isValueLiteralOf" "(" term=Term "," type=Term ")";
	public IsValueLiteralOfElements getIsValueLiteralOfAccess() {
		return pIsValueLiteralOf;
	}
	
	public ParserRule getIsValueLiteralOfRule() {
		return getIsValueLiteralOfAccess().getRule();
	}
	
	//// quantifier
	//Quantifier Formula:
	//	ForAll | Exists;
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//ForAll Quantifier:
	//	{ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	public ForAllElements getForAllAccess() {
		return pForAll;
	}
	
	public ParserRule getForAllRule() {
		return getForAllAccess().getRule();
	}
	
	//Exists Quantifier:
	//	{Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	public ExistsElements getExistsAccess() {
		return pExists;
	}
	
	public ParserRule getExistsRule() {
		return getExistsAccess().getRule();
	}
	
	//// boolean:
	//BooleanExpression Formula:
	//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//// terms:
	//Term:
	//	ReferenceBase
	//	| Concatenate
	//	| Size | IndexOf | Capitalize
	//	| Constant;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//// Base class for Rules that support navigation using Get.
	//ReferenceBase:
	//	(VariableRef | Select | GetContainer | GetContainments | GetClosure) get=Get?;
	public ReferenceBaseElements getReferenceBaseAccess() {
		return pReferenceBase;
	}
	
	public ParserRule getReferenceBaseRule() {
		return getReferenceBaseAccess().getRule();
	}
	
	//// A reference to a Variable, which can be navigated using Get.
	//VariableRef:
	//	name=[Variable];
	public VariableRefElements getVariableRefAccess() {
		return pVariableRef;
	}
	
	public ParserRule getVariableRefRule() {
		return getVariableRefAccess().getRule();
	}
	
	//// Select evaluates to all possible Variable assignments
	//// bound by the given Term, which satisfy the given formula.
	//// The result can be navigated using Get.
	//Select:
	//	"select" "(" iteration=Term "," name=Variable ":" formula=Formula ")";
	public SelectElements getSelectAccess() {
		return pSelect;
	}
	
	public ParserRule getSelectRule() {
		return getSelectAccess().getRule();
	}
	
	//// function terms (term -> term):
	//Get:
	//	"." (type=[ecore::EClass] "::")? name=[ecore::EStructuralFeature] next=Get?;
	public GetElements getGetAccess() {
		return pGet;
	}
	
	public ParserRule getGetRule() {
		return getGetAccess().getRule();
	}
	
	//GetContainer:
	//	"getContainer" "(" element=Term ")";
	public GetContainerElements getGetContainerAccess() {
		return pGetContainer;
	}
	
	public ParserRule getGetContainerRule() {
		return getGetContainerAccess().getRule();
	}
	
	//GetContainments:
	//	"getContainments" "(" element=Term ")";
	public GetContainmentsElements getGetContainmentsAccess() {
		return pGetContainments;
	}
	
	public ParserRule getGetContainmentsRule() {
		return getGetContainmentsAccess().getRule();
	}
	
	//GetClosure:
	//	"getClosure" "(" initial=Term "," variable=Variable ":" iteration=Term ")";
	public GetClosureElements getGetClosureAccess() {
		return pGetClosure;
	}
	
	public ParserRule getGetClosureRule() {
		return getGetClosureAccess().getRule();
	}
	
	//Size:
	//	"size" "(" elements=Term ")";
	public SizeElements getSizeAccess() {
		return pSize;
	}
	
	public ParserRule getSizeRule() {
		return getSizeAccess().getRule();
	}
	
	//IndexOf:
	//	"indexOf" "(" container=Term "," element=Term ")";
	public IndexOfElements getIndexOfAccess() {
		return pIndexOf;
	}
	
	public ParserRule getIndexOfRule() {
		return getIndexOfAccess().getRule();
	}
	
	//Concatenate:
	//	"concatenate" "(" left=Term "," right=Term ")";
	public ConcatenateElements getConcatenateAccess() {
		return pConcatenate;
	}
	
	public ParserRule getConcatenateRule() {
		return getConcatenateAccess().getRule();
	}
	
	//Capitalize:
	//	"capitalize" "(" string=Term ")";
	public CapitalizeElements getCapitalizeAccess() {
		return pCapitalize;
	}
	
	public ParserRule getCapitalizeRule() {
		return getCapitalizeAccess().getRule();
	}
	
	//// primitive terms:
	//Constant Term:
	//	IntConstant | StringConstant | BoolConstant | MetaConstant;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//IntConstant:
	//	value=SIGNED_INT;
	public IntConstantElements getIntConstantAccess() {
		return pIntConstant;
	}
	
	public ParserRule getIntConstantRule() {
		return getIntConstantAccess().getRule();
	}
	
	//StringConstant:
	//	value=STRING;
	public StringConstantElements getStringConstantAccess() {
		return pStringConstant;
	}
	
	public ParserRule getStringConstantRule() {
		return getStringConstantAccess().getRule();
	}
	
	//BoolConstant:
	//	value=BOOLEAN;
	public BoolConstantElements getBoolConstantAccess() {
		return pBoolConstant;
	}
	
	public ParserRule getBoolConstantRule() {
		return getBoolConstantAccess().getRule();
	}
	
	//// If classifier is an EClass, literalOrFeature may be an EStructuralFeature of that class.
	//// If classifier is an EEnum, literalOrFeature may be an EEnumLiteral of that enum.
	//// Else, literalOrValue is not set.
	//MetaConstant:
	//	"$" classifier=[ecore::EClassifier] ("::" literalOrFeature=[ecore::ENamedElement])?;
	public MetaConstantElements getMetaConstantAccess() {
		return pMetaConstant;
	}
	
	public ParserRule getMetaConstantRule() {
		return getMetaConstantAccess().getRule();
	}
	
	//terminal BOOLEAN returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//terminal SIGNED_INT returns ecore::EInt:
	//	'-'? INT;
	public TerminalRule getSIGNED_INTRule() {
		return tSIGNED_INT;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
