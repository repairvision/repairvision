/*
 * generated by Xtext 2.29.0
 */
package org.sidiff.validation.laguage.fol.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FirstOrderLogicGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ConstraintLibraryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ConstraintLibrary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDomainsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDomainsDomainParserRuleCall_0_0 = (RuleCall)cDomainsAssignment_0.eContents().get(0);
		private final Assignment cConstraintsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintsConstraintParserRuleCall_1_0 = (RuleCall)cConstraintsAssignment_1.eContents().get(0);
		
		//// NOTES:
		//// - escape keywords with ^keyword
		//// - http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
		//ConstraintLibrary:
		//    domains+=Domain*
		//    constraints+=Constraint*;
		@Override public ParserRule getRule() { return rule; }
		
		//domains+=Domain*
		//constraints+=Constraint*
		public Group getGroup() { return cGroup; }
		
		//domains+=Domain*
		public Assignment getDomainsAssignment_0() { return cDomainsAssignment_0; }
		
		//Domain
		public RuleCall getDomainsDomainParserRuleCall_0_0() { return cDomainsDomainParserRuleCall_0_0; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_1() { return cConstraintsAssignment_1; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_1_0() { return cConstraintsConstraintParserRuleCall_1_0; }
	}
	public class DomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Domain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDomainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDomainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDomainSTRINGTerminalRuleCall_1_0 = (RuleCall)cDomainAssignment_1.eContents().get(0);
		
		//Domain:
		//    'domain' domain=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'domain' domain=STRING
		public Group getGroup() { return cGroup; }
		
		//'domain'
		public Keyword getDomainKeyword_0() { return cDomainKeyword_0; }
		
		//domain=STRING
		public Assignment getDomainAssignment_1() { return cDomainAssignment_1; }
		
		//STRING
		public RuleCall getDomainSTRINGTerminalRuleCall_1_0() { return cDomainSTRINGTerminalRuleCall_1_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cMessageKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMessageSTRINGTerminalRuleCall_3_0 = (RuleCall)cMessageAssignment_3.eContents().get(0);
		private final Keyword cContextKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cVariableVariableParserRuleCall_5_0 = (RuleCall)cVariableAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		
		//Constraint:
		//    'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula
		public Group getGroup() { return cGroup; }
		
		//'constraint'
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'message'
		public Keyword getMessageKeyword_2() { return cMessageKeyword_2; }
		
		//message=STRING
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }
		
		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_3_0() { return cMessageSTRINGTerminalRuleCall_3_0; }
		
		//'context'
		public Keyword getContextKeyword_4() { return cContextKeyword_4; }
		
		//variable=Variable
		public Assignment getVariableAssignment_5() { return cVariableAssignment_5; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_5_0() { return cVariableVariableParserRuleCall_5_0; }
		
		//':'
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Variable:
		//    type=[ecore::EClassifier] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClassifier] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_0_0() { return cTypeEClassifierCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Formula");
		private final RuleCall cBinaryFormulaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// formula:
		///*
		// * Precedence: not, and, or, xor, if/implies, iff
		// *
		// * To define the precedence we must write the rule for the operator with less precedence in
		// * terms of the rule for the operator with higher precedence. This means that in the grammar,
		// * the rules for operators with less precedence are defined first.
		// */
		//// binary formulas:
		//Formula:
		//    BinaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//BinaryFormula
		public RuleCall getBinaryFormulaParserRuleCall() { return cBinaryFormulaParserRuleCall; }
	}
	public class BinaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BinaryFormula");
		private final RuleCall cIffParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BinaryFormula returns Formula:
		//    Iff;
		@Override public ParserRule getRule() { return rule; }
		
		//Iff
		public RuleCall getIffParserRuleCall() { return cIffParserRuleCall; }
	}
	public class IffElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Iff");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIfParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIffLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIfParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Iff returns Formula:
		//    If ({Iff.left=current} "=" right=If)*;
		@Override public ParserRule getRule() { return rule; }
		
		//If ({Iff.left=current} "=" right=If)*
		public Group getGroup() { return cGroup; }
		
		//If
		public RuleCall getIfParserRuleCall_0() { return cIfParserRuleCall_0; }
		
		//({Iff.left=current} "=" right=If)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Iff.left=current}
		public Action getIffLeftAction_1_0() { return cIffLeftAction_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//right=If
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//If
		public RuleCall getRightIfParserRuleCall_1_2_0() { return cRightIfParserRuleCall_1_2_0; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//If returns Formula:
		//    Xor ({If.left=current} "implies" right=Xor)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({If.left=current} "implies" right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({If.left=current} "implies" right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{If.left=current}
		public Action getIfLeftAction_1_0() { return cIfLeftAction_1_0; }
		
		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cXorKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor returns Formula:
		//    Or ({Xor.left=current} "xor" right=Or)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Xor.left=current} "xor" right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Xor.left=current} "xor" right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//"xor"
		public Keyword getXorKeyword_1_1() { return cXorKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or returns Formula:
		//    And ({Or.left=current} "or" right=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} "or" right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} "or" right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And returns Formula:
		//    BooleanExpression ({And.left=current} "and" right=BooleanExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanExpression ({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup() { return cGroup; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_0() { return cBooleanExpressionParserRuleCall_0; }
		
		//({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=BooleanExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BooleanExpression
		public RuleCall getRightBooleanExpressionParserRuleCall_1_2_0() { return cRightBooleanExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.UnaryFormula");
		private final RuleCall cNotParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// unary formulas:
		//UnaryFormula returns Formula :
		//    Not;
		@Override public ParserRule getRule() { return rule; }
		
		//Not
		public RuleCall getNotParserRuleCall() { return cNotParserRuleCall; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNotAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNotFormulaParserRuleCall_3_0 = (RuleCall)cNotAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Not returns UnaryFormula:
		//    {Not} "not" "(" not=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{Not} "not" "(" not=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }
		
		//"not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//not=Formula
		public Assignment getNotAssignment_3() { return cNotAssignment_3; }
		
		//Formula
		public RuleCall getNotFormulaParserRuleCall_3_0() { return cNotFormulaParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Predicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEqualsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInequalityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIsEmptyParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIsInstanceOfParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIsValueLiteralOfParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// predicates (term -> boolean):
		//Predicate returns Formula:
		//    Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf;
		@Override public ParserRule getRule() { return rule; }
		
		//Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Equals
		public RuleCall getEqualsParserRuleCall_0() { return cEqualsParserRuleCall_0; }
		
		//Inequality
		public RuleCall getInequalityParserRuleCall_1() { return cInequalityParserRuleCall_1; }
		
		//IsEmpty
		public RuleCall getIsEmptyParserRuleCall_2() { return cIsEmptyParserRuleCall_2; }
		
		//IsInstanceOf
		public RuleCall getIsInstanceOfParserRuleCall_3() { return cIsInstanceOfParserRuleCall_3; }
		
		//IsValueLiteralOf
		public RuleCall getIsValueLiteralOfParserRuleCall_4() { return cIsValueLiteralOfParserRuleCall_4; }
	}
	public class EqualsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Equals");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Equals:
		//    "isEqual" "(" (left=Term) "," (right=Term) ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEqual" "(" (left=Term) "," (right=Term) ")"
		public Group getGroup() { return cGroup; }
		
		//"isEqual"
		public Keyword getIsEqualKeyword_0() { return cIsEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(left=Term)
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//(right=Term)
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class InequalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Inequality");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGreaterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGreaterEqualParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSmallerParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSmallerEqualParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Inequality returns Formula:
		//    Greater | GreaterEqual | Smaller | SmallerEqual;
		@Override public ParserRule getRule() { return rule; }
		
		//Greater | GreaterEqual | Smaller | SmallerEqual
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Greater
		public RuleCall getGreaterParserRuleCall_0() { return cGreaterParserRuleCall_0; }
		
		//GreaterEqual
		public RuleCall getGreaterEqualParserRuleCall_1() { return cGreaterEqualParserRuleCall_1; }
		
		//Smaller
		public RuleCall getSmallerParserRuleCall_2() { return cSmallerParserRuleCall_2; }
		
		//SmallerEqual
		public RuleCall getSmallerEqualParserRuleCall_3() { return cSmallerEqualParserRuleCall_3; }
	}
	public class GreaterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Greater");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Greater:
		//    "isGreater" "(" (left=Term) "," (right=Term) ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreater" "(" (left=Term) "," (right=Term) ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreater"
		public Keyword getIsGreaterKeyword_0() { return cIsGreaterKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(left=Term)
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//(right=Term)
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class GreaterEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GreaterEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//GreaterEqual:
		//    "isGreaterEqual" "(" (left=Term) "," (right=Term) ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreaterEqual" "(" (left=Term) "," (right=Term) ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreaterEqual"
		public Keyword getIsGreaterEqualKeyword_0() { return cIsGreaterEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(left=Term)
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//(right=Term)
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class SmallerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Smaller");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Smaller:
		//    "isSmaller" "(" (left=Term) "," (right=Term) ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmaller" "(" (left=Term) "," (right=Term) ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmaller"
		public Keyword getIsSmallerKeyword_0() { return cIsSmallerKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(left=Term)
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//(right=Term)
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class SmallerEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SmallerEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SmallerEqual:
		//    "isSmallerEqual" "(" (left=Term) "," (right=Term) ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmallerEqual" "(" (left=Term) "," (right=Term) ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmallerEqual"
		public Keyword getIsSmallerEqualKeyword_0() { return cIsSmallerEqualKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(left=Term)
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//(right=Term)
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class IsEmptyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsEmpty");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEmptyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//IsEmpty:
		//    "isEmpty" "(" term=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEmpty" "(" term=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isEmpty"
		public Keyword getIsEmptyKeyword_0() { return cIsEmptyKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class IsInstanceOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsInstanceOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsInstanceOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeClassifierParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IsInstanceOf:
		//    "isInstanceOf" "(" term=Term "," type=Classifier ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isInstanceOf" "(" term=Term "," type=Classifier ")"
		public Group getGroup() { return cGroup; }
		
		//"isInstanceOf"
		public Keyword getIsInstanceOfKeyword_0() { return cIsInstanceOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//type=Classifier
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//Classifier
		public RuleCall getTypeClassifierParserRuleCall_4_0() { return cTypeClassifierParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class IsValueLiteralOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsValueLiteralOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsValueLiteralOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeDataTypeParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IsValueLiteralOf:
		//    "isValueLiteralOf" "(" term=Term "," type=DataType ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isValueLiteralOf" "(" term=Term "," type=DataType ")"
		public Group getGroup() { return cGroup; }
		
		//"isValueLiteralOf"
		public Keyword getIsValueLiteralOfKeyword_0() { return cIsValueLiteralOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//type=DataType
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//DataType
		public RuleCall getTypeDataTypeParserRuleCall_4_0() { return cTypeDataTypeParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForAllParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// quantifier
		//Quantifier returns Formula:
		//    ForAll | Exists;
		@Override public ParserRule getRule() { return rule; }
		
		//ForAll | Exists
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForAll
		public RuleCall getForAllParserRuleCall_0() { return cForAllParserRuleCall_0; }
		
		//Exists
		public RuleCall getExistsParserRuleCall_1() { return cExistsParserRuleCall_1; }
	}
	public class ForAllElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ForAll");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForAllAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForAllKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameVariableParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIterationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIterationTermParserRuleCall_5_0 = (RuleCall)cIterationAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//ForAll returns Quantifier:
		//    {ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{ForAll}
		public Action getForAllAction_0() { return cForAllAction_0; }
		
		//"forAll"
		public Keyword getForAllKeyword_1() { return cForAllKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=Variable
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_3_0() { return cNameVariableParserRuleCall_3_0; }
		
		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//iteration=Term
		public Assignment getIterationAssignment_5() { return cIterationAssignment_5; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_5_0() { return cIterationTermParserRuleCall_5_0; }
		
		//":"
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
	}
	public class ExistsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Exists");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameVariableParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIterationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIterationTermParserRuleCall_5_0 = (RuleCall)cIterationAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Exists returns Quantifier:
		//    {Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Exists}
		public Action getExistsAction_0() { return cExistsAction_0; }
		
		//"exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=Variable
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_3_0() { return cNameVariableParserRuleCall_3_0; }
		
		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//iteration=Term
		public Assignment getIterationAssignment_5() { return cIterationAssignment_5; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_5_0() { return cIterationTermParserRuleCall_5_0; }
		
		//":"
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BooleanExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cFormulaParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cUnaryFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPredicateParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBoolConstantParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// boolean:
		//BooleanExpression returns Formula:
		//    "(" Formula ")" | UnaryFormula | Quantifier | Predicate | BoolConstant;
		@Override public ParserRule getRule() { return rule; }
		
		//"(" Formula ")" | UnaryFormula | Quantifier | Predicate | BoolConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"(" Formula ")"
		public Group getGroup_0() { return cGroup_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_0_1() { return cFormulaParserRuleCall_0_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//UnaryFormula
		public RuleCall getUnaryFormulaParserRuleCall_1() { return cUnaryFormulaParserRuleCall_1; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_2() { return cQuantifierParserRuleCall_2; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_3() { return cPredicateParserRuleCall_3; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_4() { return cBoolConstantParserRuleCall_4; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGetContainmentsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGetContainerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGetClosureParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cSizeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cIndexOfParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cConcatenateParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cCapitalizeParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cIteratorParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//// terms:
		//Term:
		//    Constant | VariableRef | GetContainments | GetContainer | GetClosure | Size | IndexOf | Concatenate | Capitalize | Iterator;
		@Override public ParserRule getRule() { return rule; }
		
		//Constant | VariableRef | GetContainments | GetContainer | GetClosure | Size | IndexOf | Concatenate | Capitalize | Iterator
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }
		
		//VariableRef
		public RuleCall getVariableRefParserRuleCall_1() { return cVariableRefParserRuleCall_1; }
		
		//GetContainments
		public RuleCall getGetContainmentsParserRuleCall_2() { return cGetContainmentsParserRuleCall_2; }
		
		//GetContainer
		public RuleCall getGetContainerParserRuleCall_3() { return cGetContainerParserRuleCall_3; }
		
		//GetClosure
		public RuleCall getGetClosureParserRuleCall_4() { return cGetClosureParserRuleCall_4; }
		
		//Size
		public RuleCall getSizeParserRuleCall_5() { return cSizeParserRuleCall_5; }
		
		//IndexOf
		public RuleCall getIndexOfParserRuleCall_6() { return cIndexOfParserRuleCall_6; }
		
		//Concatenate
		public RuleCall getConcatenateParserRuleCall_7() { return cConcatenateParserRuleCall_7; }
		
		//Capitalize
		public RuleCall getCapitalizeParserRuleCall_8() { return cCapitalizeParserRuleCall_8; }
		
		//Iterator
		public RuleCall getIteratorParserRuleCall_9() { return cIteratorParserRuleCall_9; }
	}
	public class VariableRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.VariableRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameVariableCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cNameVariableCrossReference_1_0.eContents().get(1);
		private final Assignment cGetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGetGetParserRuleCall_2_0 = (RuleCall)cGetAssignment_2.eContents().get(0);
		
		//VariableRef returns Term:
		//    {VariableRef} name=[Variable] (get=Get)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableRef} name=[Variable] (get=Get)?
		public Group getGroup() { return cGroup; }
		
		//{VariableRef}
		public Action getVariableRefAction_0() { return cVariableRefAction_0; }
		
		//name=[Variable]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[Variable]
		public CrossReference getNameVariableCrossReference_1_0() { return cNameVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getNameVariableIDTerminalRuleCall_1_0_1() { return cNameVariableIDTerminalRuleCall_1_0_1; }
		
		//(get=Get)?
		public Assignment getGetAssignment_2() { return cGetAssignment_2; }
		
		//Get
		public RuleCall getGetGetParserRuleCall_2_0() { return cGetGetParserRuleCall_2_0; }
	}
	public class GetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Get");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_1_0_0 = (CrossReference)cTypeAssignment_1_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_1_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_1_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNameEStructuralFeatureCrossReference_2_0 = (CrossReference)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameEStructuralFeatureIDTerminalRuleCall_2_0_1 = (RuleCall)cNameEStructuralFeatureCrossReference_2_0.eContents().get(1);
		private final Assignment cNextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNextGetParserRuleCall_3_0 = (RuleCall)cNextAssignment_3.eContents().get(0);
		
		//// function terms (term -> term):
		//Get:
		//    "." (type=[ecore::EClassifier] "::" )? name=[ecore::EStructuralFeature] (next=Get)?;
		@Override public ParserRule getRule() { return rule; }
		
		//"." (type=[ecore::EClassifier] "::" )? name=[ecore::EStructuralFeature] (next=Get)?
		public Group getGroup() { return cGroup; }
		
		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//(type=[ecore::EClassifier] "::" )?
		public Group getGroup_1() { return cGroup_1; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_1_0_0() { return cTypeEClassifierCrossReference_1_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_1_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_1_0_0_1; }
		
		//"::"
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//name=[ecore::EStructuralFeature]
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//[ecore::EStructuralFeature]
		public CrossReference getNameEStructuralFeatureCrossReference_2_0() { return cNameEStructuralFeatureCrossReference_2_0; }
		
		//ID
		public RuleCall getNameEStructuralFeatureIDTerminalRuleCall_2_0_1() { return cNameEStructuralFeatureIDTerminalRuleCall_2_0_1; }
		
		//(next=Get)?
		public Assignment getNextAssignment_3() { return cNextAssignment_3; }
		
		//Get
		public RuleCall getNextGetParserRuleCall_3_0() { return cNextGetParserRuleCall_3_0; }
	}
	public class GetContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementTermParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GetContainer:
		//    "getContainer" "(" element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainer" "(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainer"
		public Keyword getGetContainerKeyword_0() { return cGetContainerKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//element=Term
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_2_0() { return cElementTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class GetContainmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainmentsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementTermParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GetContainments:
		//    "getContainments" "(" element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainments" "(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainments"
		public Keyword getGetContainmentsKeyword_0() { return cGetContainmentsKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//element=Term
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_2_0() { return cElementTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class GetClosureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetClosure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetClosureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementTermParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFeatureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFeatureFeatureConstantParserRuleCall_4_0 = (RuleCall)cFeatureAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//GetClosure:
		//    "getClosure" "(" element=Term "," feature=FeatureConstant ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"getClosure" "(" element=Term "," feature=FeatureConstant ")"
		public Group getGroup() { return cGroup; }
		
		//"getClosure"
		public Keyword getGetClosureKeyword_0() { return cGetClosureKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//element=Term
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_2_0() { return cElementTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//feature=FeatureConstant
		public Assignment getFeatureAssignment_4() { return cFeatureAssignment_4; }
		
		//FeatureConstant
		public RuleCall getFeatureFeatureConstantParserRuleCall_4_0() { return cFeatureFeatureConstantParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class SizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Size");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementsTermParserRuleCall_2_0 = (RuleCall)cElementsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Size:
		//    "size" "(" elements=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"size" "(" elements=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"size"
		public Keyword getSizeKeyword_0() { return cSizeKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//elements=Term
		public Assignment getElementsAssignment_2() { return cElementsAssignment_2; }
		
		//Term
		public RuleCall getElementsTermParserRuleCall_2_0() { return cElementsTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class IndexOfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IndexOf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIndexOfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cContainerAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContainerTermParserRuleCall_2_0 = (RuleCall)cContainerAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFeatureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFeatureFeatureConstantParserRuleCall_4_0 = (RuleCall)cFeatureAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cElementAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cElementTermParserRuleCall_6_0 = (RuleCall)cElementAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//IndexOf:
		//    "indexOf" "(" container=Term "," feature=FeatureConstant "," element=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"indexOf" "(" container=Term "," feature=FeatureConstant "," element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"indexOf"
		public Keyword getIndexOfKeyword_0() { return cIndexOfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//container=Term
		public Assignment getContainerAssignment_2() { return cContainerAssignment_2; }
		
		//Term
		public RuleCall getContainerTermParserRuleCall_2_0() { return cContainerTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//feature=FeatureConstant
		public Assignment getFeatureAssignment_4() { return cFeatureAssignment_4; }
		
		//FeatureConstant
		public RuleCall getFeatureFeatureConstantParserRuleCall_4_0() { return cFeatureFeatureConstantParserRuleCall_4_0; }
		
		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//element=Term
		public Assignment getElementAssignment_6() { return cElementAssignment_6; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_6_0() { return cElementTermParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class ConcatenateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Concatenate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConcatenateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftTermParserRuleCall_2_0 = (RuleCall)cLeftAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightTermParserRuleCall_4_0 = (RuleCall)cRightAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Concatenate :
		//    "concatenate" "(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"concatenate" "(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"concatenate"
		public Keyword getConcatenateKeyword_0() { return cConcatenateKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//left=Term
		public Assignment getLeftAssignment_2() { return cLeftAssignment_2; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_2_0() { return cLeftTermParserRuleCall_2_0; }
		
		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//right=Term
		public Assignment getRightAssignment_4() { return cRightAssignment_4; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_4_0() { return cRightTermParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class CapitalizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Capitalize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCapitalizeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStringAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStringTermParserRuleCall_2_0 = (RuleCall)cStringAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Capitalize :
		//    "capitalize" "(" string=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"capitalize" "(" string=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"capitalize"
		public Keyword getCapitalizeKeyword_0() { return cCapitalizeKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//string=Term
		public Assignment getStringAssignment_2() { return cStringAssignment_2; }
		
		//Term
		public RuleCall getStringTermParserRuleCall_2_0() { return cStringTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class IteratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Iterator");
		private final RuleCall cSelectParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// iterators
		//Iterator returns Term:
		//    Select;
		@Override public ParserRule getRule() { return rule; }
		
		//Select
		public RuleCall getSelectParserRuleCall() { return cSelectParserRuleCall; }
	}
	public class SelectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Select");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelectAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelectKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameVariableParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIterationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cIterationTermParserRuleCall_5_0 = (RuleCall)cIterationAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//Select returns Iterator:
		//    {Select} "select" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{Select} "select" "(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Select}
		public Action getSelectAction_0() { return cSelectAction_0; }
		
		//"select"
		public Keyword getSelectKeyword_1() { return cSelectKeyword_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//name=Variable
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_3_0() { return cNameVariableParserRuleCall_3_0; }
		
		//"in"
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//iteration=Term
		public Assignment getIterationAssignment_5() { return cIterationAssignment_5; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_5_0() { return cIterationTermParserRuleCall_5_0; }
		
		//":"
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
	}
	public class FeatureConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.FeatureConstant");
		private final Assignment cConstantAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConstantEStructuralFeatureCrossReference_0 = (CrossReference)cConstantAssignment.eContents().get(0);
		private final RuleCall cConstantEStructuralFeatureIDTerminalRuleCall_0_1 = (RuleCall)cConstantEStructuralFeatureCrossReference_0.eContents().get(1);
		
		//// type constants and type references:
		//FeatureConstant:
		//    constant=[ecore::EStructuralFeature];
		@Override public ParserRule getRule() { return rule; }
		
		//constant=[ecore::EStructuralFeature]
		public Assignment getConstantAssignment() { return cConstantAssignment; }
		
		//[ecore::EStructuralFeature]
		public CrossReference getConstantEStructuralFeatureCrossReference_0() { return cConstantEStructuralFeatureCrossReference_0; }
		
		//ID
		public RuleCall getConstantEStructuralFeatureIDTerminalRuleCall_0_1() { return cConstantEStructuralFeatureIDTerminalRuleCall_0_1; }
	}
	public class ClassifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Classifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassifierConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAsClassifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Classifier:
		//    ClassifierConstant | AsClassifier;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassifierConstant | AsClassifier
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ClassifierConstant
		public RuleCall getClassifierConstantParserRuleCall_0() { return cClassifierConstantParserRuleCall_0; }
		
		//AsClassifier
		public RuleCall getAsClassifierParserRuleCall_1() { return cAsClassifierParserRuleCall_1; }
	}
	public class ClassifierConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ClassifierConstant");
		private final Assignment cConstantAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConstantEClassifierCrossReference_0 = (CrossReference)cConstantAssignment.eContents().get(0);
		private final RuleCall cConstantEClassifierIDTerminalRuleCall_0_1 = (RuleCall)cConstantEClassifierCrossReference_0.eContents().get(1);
		
		//ClassifierConstant:
		//    constant=[ecore::EClassifier];
		@Override public ParserRule getRule() { return rule; }
		
		//constant=[ecore::EClassifier]
		public Assignment getConstantAssignment() { return cConstantAssignment; }
		
		//[ecore::EClassifier]
		public CrossReference getConstantEClassifierCrossReference_0() { return cConstantEClassifierCrossReference_0; }
		
		//ID
		public RuleCall getConstantEClassifierIDTerminalRuleCall_0_1() { return cConstantEClassifierIDTerminalRuleCall_0_1; }
	}
	public class AsClassifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.AsClassifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAsClassifierKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//AsClassifier:
		//    "asClassifier" "(" term=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"asClassifier" "(" term=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"asClassifier"
		public Keyword getAsClassifierKeyword_0() { return cAsClassifierKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class DataTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.DataType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataTypeConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAsDataTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DataType:
		//    DataTypeConstant | AsDataType;
		@Override public ParserRule getRule() { return rule; }
		
		//DataTypeConstant | AsDataType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DataTypeConstant
		public RuleCall getDataTypeConstantParserRuleCall_0() { return cDataTypeConstantParserRuleCall_0; }
		
		//AsDataType
		public RuleCall getAsDataTypeParserRuleCall_1() { return cAsDataTypeParserRuleCall_1; }
	}
	public class DataTypeConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.DataTypeConstant");
		private final Assignment cConstantAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConstantEDataTypeCrossReference_0 = (CrossReference)cConstantAssignment.eContents().get(0);
		private final RuleCall cConstantEDataTypeIDTerminalRuleCall_0_1 = (RuleCall)cConstantEDataTypeCrossReference_0.eContents().get(1);
		
		//DataTypeConstant:
		//    constant=[ecore::EDataType];
		@Override public ParserRule getRule() { return rule; }
		
		//constant=[ecore::EDataType]
		public Assignment getConstantAssignment() { return cConstantAssignment; }
		
		//[ecore::EDataType]
		public CrossReference getConstantEDataTypeCrossReference_0() { return cConstantEDataTypeCrossReference_0; }
		
		//ID
		public RuleCall getConstantEDataTypeIDTerminalRuleCall_0_1() { return cConstantEDataTypeIDTerminalRuleCall_0_1; }
	}
	public class AsDataTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.AsDataType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAsDataTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//AsDataType:
		//    "asDataType" "(" term=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"asDataType" "(" term=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"asDataType"
		public Keyword getAsDataTypeKeyword_0() { return cAsDataTypeKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBoolConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// primitive constants:
		//Constant returns Term:
		//    IntConstant | StringConstant | BoolConstant;
		@Override public ParserRule getRule() { return rule; }
		
		//IntConstant | StringConstant | BoolConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntConstant
		public RuleCall getIntConstantParserRuleCall_0() { return cIntConstantParserRuleCall_0; }
		
		//StringConstant
		public RuleCall getStringConstantParserRuleCall_1() { return cStringConstantParserRuleCall_1; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_2() { return cBoolConstantParserRuleCall_2; }
	}
	public class IntConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IntConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSIGNED_INTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntConstant:
		//    value=SIGNED_INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=SIGNED_INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//SIGNED_INT
		public RuleCall getValueSIGNED_INTTerminalRuleCall_0() { return cValueSIGNED_INTTerminalRuleCall_0; }
	}
	public class StringConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.StringConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringConstant:
		//    value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class BoolConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BoolConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BoolConstant:
		//    value=BOOLEAN;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}
	
	
	private final ConstraintLibraryElements pConstraintLibrary;
	private final DomainElements pDomain;
	private final ConstraintElements pConstraint;
	private final VariableElements pVariable;
	private final FormulaElements pFormula;
	private final BinaryFormulaElements pBinaryFormula;
	private final IffElements pIff;
	private final IfElements pIf;
	private final XorElements pXor;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final UnaryFormulaElements pUnaryFormula;
	private final NotElements pNot;
	private final PredicateElements pPredicate;
	private final EqualsElements pEquals;
	private final InequalityElements pInequality;
	private final GreaterElements pGreater;
	private final GreaterEqualElements pGreaterEqual;
	private final SmallerElements pSmaller;
	private final SmallerEqualElements pSmallerEqual;
	private final IsEmptyElements pIsEmpty;
	private final IsInstanceOfElements pIsInstanceOf;
	private final IsValueLiteralOfElements pIsValueLiteralOf;
	private final QuantifierElements pQuantifier;
	private final ForAllElements pForAll;
	private final ExistsElements pExists;
	private final BooleanExpressionElements pBooleanExpression;
	private final TermElements pTerm;
	private final VariableRefElements pVariableRef;
	private final GetElements pGet;
	private final GetContainerElements pGetContainer;
	private final GetContainmentsElements pGetContainments;
	private final GetClosureElements pGetClosure;
	private final SizeElements pSize;
	private final IndexOfElements pIndexOf;
	private final ConcatenateElements pConcatenate;
	private final CapitalizeElements pCapitalize;
	private final IteratorElements pIterator;
	private final SelectElements pSelect;
	private final FeatureConstantElements pFeatureConstant;
	private final ClassifierElements pClassifier;
	private final ClassifierConstantElements pClassifierConstant;
	private final AsClassifierElements pAsClassifier;
	private final DataTypeElements pDataType;
	private final DataTypeConstantElements pDataTypeConstant;
	private final AsDataTypeElements pAsDataType;
	private final ConstantElements pConstant;
	private final IntConstantElements pIntConstant;
	private final StringConstantElements pStringConstant;
	private final BoolConstantElements pBoolConstant;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tSIGNED_INT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FirstOrderLogicGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pConstraintLibrary = new ConstraintLibraryElements();
		this.pDomain = new DomainElements();
		this.pConstraint = new ConstraintElements();
		this.pVariable = new VariableElements();
		this.pFormula = new FormulaElements();
		this.pBinaryFormula = new BinaryFormulaElements();
		this.pIff = new IffElements();
		this.pIf = new IfElements();
		this.pXor = new XorElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pUnaryFormula = new UnaryFormulaElements();
		this.pNot = new NotElements();
		this.pPredicate = new PredicateElements();
		this.pEquals = new EqualsElements();
		this.pInequality = new InequalityElements();
		this.pGreater = new GreaterElements();
		this.pGreaterEqual = new GreaterEqualElements();
		this.pSmaller = new SmallerElements();
		this.pSmallerEqual = new SmallerEqualElements();
		this.pIsEmpty = new IsEmptyElements();
		this.pIsInstanceOf = new IsInstanceOfElements();
		this.pIsValueLiteralOf = new IsValueLiteralOfElements();
		this.pQuantifier = new QuantifierElements();
		this.pForAll = new ForAllElements();
		this.pExists = new ExistsElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pTerm = new TermElements();
		this.pVariableRef = new VariableRefElements();
		this.pGet = new GetElements();
		this.pGetContainer = new GetContainerElements();
		this.pGetContainments = new GetContainmentsElements();
		this.pGetClosure = new GetClosureElements();
		this.pSize = new SizeElements();
		this.pIndexOf = new IndexOfElements();
		this.pConcatenate = new ConcatenateElements();
		this.pCapitalize = new CapitalizeElements();
		this.pIterator = new IteratorElements();
		this.pSelect = new SelectElements();
		this.pFeatureConstant = new FeatureConstantElements();
		this.pClassifier = new ClassifierElements();
		this.pClassifierConstant = new ClassifierConstantElements();
		this.pAsClassifier = new AsClassifierElements();
		this.pDataType = new DataTypeElements();
		this.pDataTypeConstant = new DataTypeConstantElements();
		this.pAsDataType = new AsDataTypeElements();
		this.pConstant = new ConstantElements();
		this.pIntConstant = new IntConstantElements();
		this.pStringConstant = new StringConstantElements();
		this.pBoolConstant = new BoolConstantElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BOOLEAN");
		this.tSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SIGNED_INT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.sidiff.validation.laguage.fol.FirstOrderLogic".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// NOTES:
	//// - escape keywords with ^keyword
	//// - http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
	//ConstraintLibrary:
	//    domains+=Domain*
	//    constraints+=Constraint*;
	public ConstraintLibraryElements getConstraintLibraryAccess() {
		return pConstraintLibrary;
	}
	
	public ParserRule getConstraintLibraryRule() {
		return getConstraintLibraryAccess().getRule();
	}
	
	//Domain:
	//    'domain' domain=STRING;
	public DomainElements getDomainAccess() {
		return pDomain;
	}
	
	public ParserRule getDomainRule() {
		return getDomainAccess().getRule();
	}
	
	//Constraint:
	//    'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//Variable:
	//    type=[ecore::EClassifier] name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//// formula:
	///*
	// * Precedence: not, and, or, xor, if/implies, iff
	// *
	// * To define the precedence we must write the rule for the operator with less precedence in
	// * terms of the rule for the operator with higher precedence. This means that in the grammar,
	// * the rules for operators with less precedence are defined first.
	// */
	//// binary formulas:
	//Formula:
	//    BinaryFormula;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//BinaryFormula returns Formula:
	//    Iff;
	public BinaryFormulaElements getBinaryFormulaAccess() {
		return pBinaryFormula;
	}
	
	public ParserRule getBinaryFormulaRule() {
		return getBinaryFormulaAccess().getRule();
	}
	
	//Iff returns Formula:
	//    If ({Iff.left=current} "=" right=If)*;
	public IffElements getIffAccess() {
		return pIff;
	}
	
	public ParserRule getIffRule() {
		return getIffAccess().getRule();
	}
	
	//If returns Formula:
	//    Xor ({If.left=current} "implies" right=Xor)*;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//Xor returns Formula:
	//    Or ({Xor.left=current} "xor" right=Or)*;
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Or returns Formula:
	//    And ({Or.left=current} "or" right=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And returns Formula:
	//    BooleanExpression ({And.left=current} "and" right=BooleanExpression)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//// unary formulas:
	//UnaryFormula returns Formula :
	//    Not;
	public UnaryFormulaElements getUnaryFormulaAccess() {
		return pUnaryFormula;
	}
	
	public ParserRule getUnaryFormulaRule() {
		return getUnaryFormulaAccess().getRule();
	}
	
	//Not returns UnaryFormula:
	//    {Not} "not" "(" not=Formula ")";
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//// predicates (term -> boolean):
	//Predicate returns Formula:
	//    Equals | Inequality | IsEmpty | IsInstanceOf | IsValueLiteralOf;
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//Equals:
	//    "isEqual" "(" (left=Term) "," (right=Term) ")";
	public EqualsElements getEqualsAccess() {
		return pEquals;
	}
	
	public ParserRule getEqualsRule() {
		return getEqualsAccess().getRule();
	}
	
	//Inequality returns Formula:
	//    Greater | GreaterEqual | Smaller | SmallerEqual;
	public InequalityElements getInequalityAccess() {
		return pInequality;
	}
	
	public ParserRule getInequalityRule() {
		return getInequalityAccess().getRule();
	}
	
	//Greater:
	//    "isGreater" "(" (left=Term) "," (right=Term) ")";
	public GreaterElements getGreaterAccess() {
		return pGreater;
	}
	
	public ParserRule getGreaterRule() {
		return getGreaterAccess().getRule();
	}
	
	//GreaterEqual:
	//    "isGreaterEqual" "(" (left=Term) "," (right=Term) ")";
	public GreaterEqualElements getGreaterEqualAccess() {
		return pGreaterEqual;
	}
	
	public ParserRule getGreaterEqualRule() {
		return getGreaterEqualAccess().getRule();
	}
	
	//Smaller:
	//    "isSmaller" "(" (left=Term) "," (right=Term) ")";
	public SmallerElements getSmallerAccess() {
		return pSmaller;
	}
	
	public ParserRule getSmallerRule() {
		return getSmallerAccess().getRule();
	}
	
	//SmallerEqual:
	//    "isSmallerEqual" "(" (left=Term) "," (right=Term) ")";
	public SmallerEqualElements getSmallerEqualAccess() {
		return pSmallerEqual;
	}
	
	public ParserRule getSmallerEqualRule() {
		return getSmallerEqualAccess().getRule();
	}
	
	//IsEmpty:
	//    "isEmpty" "(" term=Term ")";
	public IsEmptyElements getIsEmptyAccess() {
		return pIsEmpty;
	}
	
	public ParserRule getIsEmptyRule() {
		return getIsEmptyAccess().getRule();
	}
	
	//IsInstanceOf:
	//    "isInstanceOf" "(" term=Term "," type=Classifier ")";
	public IsInstanceOfElements getIsInstanceOfAccess() {
		return pIsInstanceOf;
	}
	
	public ParserRule getIsInstanceOfRule() {
		return getIsInstanceOfAccess().getRule();
	}
	
	//IsValueLiteralOf:
	//    "isValueLiteralOf" "(" term=Term "," type=DataType ")";
	public IsValueLiteralOfElements getIsValueLiteralOfAccess() {
		return pIsValueLiteralOf;
	}
	
	public ParserRule getIsValueLiteralOfRule() {
		return getIsValueLiteralOfAccess().getRule();
	}
	
	//// quantifier
	//Quantifier returns Formula:
	//    ForAll | Exists;
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//ForAll returns Quantifier:
	//    {ForAll} "forAll" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	public ForAllElements getForAllAccess() {
		return pForAll;
	}
	
	public ParserRule getForAllRule() {
		return getForAllAccess().getRule();
	}
	
	//Exists returns Quantifier:
	//    {Exists} "exists" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	public ExistsElements getExistsAccess() {
		return pExists;
	}
	
	public ParserRule getExistsRule() {
		return getExistsAccess().getRule();
	}
	
	//// boolean:
	//BooleanExpression returns Formula:
	//    "(" Formula ")" | UnaryFormula | Quantifier | Predicate | BoolConstant;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//// terms:
	//Term:
	//    Constant | VariableRef | GetContainments | GetContainer | GetClosure | Size | IndexOf | Concatenate | Capitalize | Iterator;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//VariableRef returns Term:
	//    {VariableRef} name=[Variable] (get=Get)?;
	public VariableRefElements getVariableRefAccess() {
		return pVariableRef;
	}
	
	public ParserRule getVariableRefRule() {
		return getVariableRefAccess().getRule();
	}
	
	//// function terms (term -> term):
	//Get:
	//    "." (type=[ecore::EClassifier] "::" )? name=[ecore::EStructuralFeature] (next=Get)?;
	public GetElements getGetAccess() {
		return pGet;
	}
	
	public ParserRule getGetRule() {
		return getGetAccess().getRule();
	}
	
	//GetContainer:
	//    "getContainer" "(" element=Term ")";
	public GetContainerElements getGetContainerAccess() {
		return pGetContainer;
	}
	
	public ParserRule getGetContainerRule() {
		return getGetContainerAccess().getRule();
	}
	
	//GetContainments:
	//    "getContainments" "(" element=Term ")";
	public GetContainmentsElements getGetContainmentsAccess() {
		return pGetContainments;
	}
	
	public ParserRule getGetContainmentsRule() {
		return getGetContainmentsAccess().getRule();
	}
	
	//GetClosure:
	//    "getClosure" "(" element=Term "," feature=FeatureConstant ")";
	public GetClosureElements getGetClosureAccess() {
		return pGetClosure;
	}
	
	public ParserRule getGetClosureRule() {
		return getGetClosureAccess().getRule();
	}
	
	//Size:
	//    "size" "(" elements=Term ")";
	public SizeElements getSizeAccess() {
		return pSize;
	}
	
	public ParserRule getSizeRule() {
		return getSizeAccess().getRule();
	}
	
	//IndexOf:
	//    "indexOf" "(" container=Term "," feature=FeatureConstant "," element=Term ")";
	public IndexOfElements getIndexOfAccess() {
		return pIndexOf;
	}
	
	public ParserRule getIndexOfRule() {
		return getIndexOfAccess().getRule();
	}
	
	//Concatenate :
	//    "concatenate" "(" left=Term "," right=Term ")";
	public ConcatenateElements getConcatenateAccess() {
		return pConcatenate;
	}
	
	public ParserRule getConcatenateRule() {
		return getConcatenateAccess().getRule();
	}
	
	//Capitalize :
	//    "capitalize" "(" string=Term ")";
	public CapitalizeElements getCapitalizeAccess() {
		return pCapitalize;
	}
	
	public ParserRule getCapitalizeRule() {
		return getCapitalizeAccess().getRule();
	}
	
	//// iterators
	//Iterator returns Term:
	//    Select;
	public IteratorElements getIteratorAccess() {
		return pIterator;
	}
	
	public ParserRule getIteratorRule() {
		return getIteratorAccess().getRule();
	}
	
	//Select returns Iterator:
	//    {Select} "select" "(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	public SelectElements getSelectAccess() {
		return pSelect;
	}
	
	public ParserRule getSelectRule() {
		return getSelectAccess().getRule();
	}
	
	//// type constants and type references:
	//FeatureConstant:
	//    constant=[ecore::EStructuralFeature];
	public FeatureConstantElements getFeatureConstantAccess() {
		return pFeatureConstant;
	}
	
	public ParserRule getFeatureConstantRule() {
		return getFeatureConstantAccess().getRule();
	}
	
	//Classifier:
	//    ClassifierConstant | AsClassifier;
	public ClassifierElements getClassifierAccess() {
		return pClassifier;
	}
	
	public ParserRule getClassifierRule() {
		return getClassifierAccess().getRule();
	}
	
	//ClassifierConstant:
	//    constant=[ecore::EClassifier];
	public ClassifierConstantElements getClassifierConstantAccess() {
		return pClassifierConstant;
	}
	
	public ParserRule getClassifierConstantRule() {
		return getClassifierConstantAccess().getRule();
	}
	
	//AsClassifier:
	//    "asClassifier" "(" term=Term ")";
	public AsClassifierElements getAsClassifierAccess() {
		return pAsClassifier;
	}
	
	public ParserRule getAsClassifierRule() {
		return getAsClassifierAccess().getRule();
	}
	
	//DataType:
	//    DataTypeConstant | AsDataType;
	public DataTypeElements getDataTypeAccess() {
		return pDataType;
	}
	
	public ParserRule getDataTypeRule() {
		return getDataTypeAccess().getRule();
	}
	
	//DataTypeConstant:
	//    constant=[ecore::EDataType];
	public DataTypeConstantElements getDataTypeConstantAccess() {
		return pDataTypeConstant;
	}
	
	public ParserRule getDataTypeConstantRule() {
		return getDataTypeConstantAccess().getRule();
	}
	
	//AsDataType:
	//    "asDataType" "(" term=Term ")";
	public AsDataTypeElements getAsDataTypeAccess() {
		return pAsDataType;
	}
	
	public ParserRule getAsDataTypeRule() {
		return getAsDataTypeAccess().getRule();
	}
	
	//// primitive constants:
	//Constant returns Term:
	//    IntConstant | StringConstant | BoolConstant;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//IntConstant:
	//    value=SIGNED_INT;
	public IntConstantElements getIntConstantAccess() {
		return pIntConstant;
	}
	
	public ParserRule getIntConstantRule() {
		return getIntConstantAccess().getRule();
	}
	
	//StringConstant:
	//    value=STRING;
	public StringConstantElements getStringConstantAccess() {
		return pStringConstant;
	}
	
	public ParserRule getStringConstantRule() {
		return getStringConstantAccess().getRule();
	}
	
	//BoolConstant:
	//    value=BOOLEAN;
	public BoolConstantElements getBoolConstantAccess() {
		return pBoolConstant;
	}
	
	public ParserRule getBoolConstantRule() {
		return getBoolConstantAccess().getRule();
	}
	
	//// terminals:
	//terminal BOOLEAN returns ecore::EBoolean:
	//    'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//terminal SIGNED_INT returns ecore::EInt:
	//    '-'? INT;
	public TerminalRule getSIGNED_INTRule() {
		return tSIGNED_INT;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
