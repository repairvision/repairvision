/*
 * generated by Xtext 2.21.0
 */
package org.sidiff.validation.laguage.fol.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sidiff.validation.laguage.fol.firstOrderLogic.And;
import org.sidiff.validation.laguage.fol.firstOrderLogic.BoolConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Capitalize;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Concatenate;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Constraint;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ConstraintLibrary;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Equals;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Exists;
import org.sidiff.validation.laguage.fol.firstOrderLogic.FirstOrderLogicPackage;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ForAll;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Get;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetClosure;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainer;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainments;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Greater;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GreaterEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.If;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Iff;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Import;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IndexOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IntConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsEmpty;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsInstanceOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsValueLiteralOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.MetaConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Not;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Or;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Select;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Size;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Smaller;
import org.sidiff.validation.laguage.fol.firstOrderLogic.SmallerEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.StringConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Variable;
import org.sidiff.validation.laguage.fol.firstOrderLogic.VariableRef;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Xor;
import org.sidiff.validation.laguage.fol.services.FirstOrderLogicGrammarAccess;

@SuppressWarnings("all")
public class FirstOrderLogicSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FirstOrderLogicGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FirstOrderLogicPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FirstOrderLogicPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case FirstOrderLogicPackage.BOOL_CONSTANT:
				sequence_BoolConstant(context, (BoolConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CAPITALIZE:
				sequence_Capitalize(context, (Capitalize) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CONCATENATE:
				sequence_Concatenate(context, (Concatenate) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CONSTRAINT_LIBRARY:
				sequence_ConstraintLibrary(context, (ConstraintLibrary) semanticObject); 
				return; 
			case FirstOrderLogicPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case FirstOrderLogicPackage.EXISTS:
				sequence_Exists(context, (Exists) semanticObject); 
				return; 
			case FirstOrderLogicPackage.FOR_ALL:
				sequence_ForAll(context, (ForAll) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GET:
				sequence_Get(context, (Get) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GET_CLOSURE:
				if (rule == grammarAccess.getGetClosureRule()) {
					sequence_GetClosure(context, (GetClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getReferenceBaseRule()) {
					sequence_GetClosure_ReferenceBase(context, (GetClosure) semanticObject); 
					return; 
				}
				else break;
			case FirstOrderLogicPackage.GET_CONTAINER:
				if (rule == grammarAccess.getGetContainerRule()) {
					sequence_GetContainer(context, (GetContainer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getReferenceBaseRule()) {
					sequence_GetContainer_ReferenceBase(context, (GetContainer) semanticObject); 
					return; 
				}
				else break;
			case FirstOrderLogicPackage.GET_CONTAINMENTS:
				if (rule == grammarAccess.getGetContainmentsRule()) {
					sequence_GetContainments(context, (GetContainments) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getReferenceBaseRule()) {
					sequence_GetContainments_ReferenceBase(context, (GetContainments) semanticObject); 
					return; 
				}
				else break;
			case FirstOrderLogicPackage.GREATER:
				sequence_Greater(context, (Greater) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GREATER_EQUAL:
				sequence_GreaterEqual(context, (GreaterEqual) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IFF:
				sequence_Iff(context, (Iff) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case FirstOrderLogicPackage.INDEX_OF:
				sequence_IndexOf(context, (IndexOf) semanticObject); 
				return; 
			case FirstOrderLogicPackage.INT_CONSTANT:
				sequence_IntConstant(context, (IntConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IS_EMPTY:
				sequence_IsEmpty(context, (IsEmpty) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IS_INSTANCE_OF:
				sequence_IsInstanceOf(context, (IsInstanceOf) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IS_VALUE_LITERAL_OF:
				sequence_IsValueLiteralOf(context, (IsValueLiteralOf) semanticObject); 
				return; 
			case FirstOrderLogicPackage.META_CONSTANT:
				sequence_MetaConstant(context, (MetaConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case FirstOrderLogicPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case FirstOrderLogicPackage.SELECT:
				if (rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getReferenceBaseRule()) {
					sequence_ReferenceBase_Select(context, (Select) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectRule()) {
					sequence_Select(context, (Select) semanticObject); 
					return; 
				}
				else break;
			case FirstOrderLogicPackage.SIZE:
				sequence_Size(context, (Size) semanticObject); 
				return; 
			case FirstOrderLogicPackage.SMALLER:
				sequence_Smaller(context, (Smaller) semanticObject); 
				return; 
			case FirstOrderLogicPackage.SMALLER_EQUAL:
				sequence_SmallerEqual(context, (SmallerEqual) semanticObject); 
				return; 
			case FirstOrderLogicPackage.STRING_CONSTANT:
				sequence_StringConstant(context, (StringConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case FirstOrderLogicPackage.VARIABLE_REF:
				if (rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getReferenceBaseRule()) {
					sequence_ReferenceBase_VariableRef(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableRefRule()) {
					sequence_VariableRef(context, (VariableRef) semanticObject); 
					return; 
				}
				else break;
			case FirstOrderLogicPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Formula returns And
	 *     BinaryFormula returns And
	 *     Iff returns And
	 *     Iff.Iff_1_0 returns And
	 *     If returns And
	 *     If.If_1_0 returns And
	 *     Xor returns And
	 *     Xor.Xor_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     BooleanExpression returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=BooleanExpression)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightBooleanExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns BoolConstant
	 *     BinaryFormula returns BoolConstant
	 *     Iff returns BoolConstant
	 *     Iff.Iff_1_0 returns BoolConstant
	 *     If returns BoolConstant
	 *     If.If_1_0 returns BoolConstant
	 *     Xor returns BoolConstant
	 *     Xor.Xor_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     BooleanExpression returns BoolConstant
	 *     Term returns BoolConstant
	 *     Constant returns BoolConstant
	 *     BoolConstant returns BoolConstant
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BoolConstant(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.BOOL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.BOOL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolConstantAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Capitalize
	 *     Capitalize returns Capitalize
	 *
	 * Constraint:
	 *     string=Term
	 */
	protected void sequence_Capitalize(ISerializationContext context, Capitalize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CAPITALIZE__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CAPITALIZE__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCapitalizeAccess().getStringTermParserRuleCall_2_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Concatenate
	 *     Concatenate returns Concatenate
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Concatenate(ISerializationContext context, Concatenate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONCATENATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONCATENATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONCATENATE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONCATENATE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatenateAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConcatenateAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintLibrary returns ConstraintLibrary
	 *
	 * Constraint:
	 *     ((imports+=Import+ constraints+=Constraint+) | constraints+=Constraint+)?
	 */
	protected void sequence_ConstraintLibrary(ISerializationContext context, ConstraintLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=ID message=STRING variable=Variable type=[EClassifier|ID]? formula=Formula)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Equals
	 *     BinaryFormula returns Equals
	 *     Iff returns Equals
	 *     Iff.Iff_1_0 returns Equals
	 *     If returns Equals
	 *     If.If_1_0 returns Equals
	 *     Xor returns Equals
	 *     Xor.Xor_1_0 returns Equals
	 *     Or returns Equals
	 *     Or.Or_1_0 returns Equals
	 *     And returns Equals
	 *     And.And_1_0 returns Equals
	 *     Predicate returns Equals
	 *     Equals returns Equals
	 *     BooleanExpression returns Equals
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Exists
	 *     BinaryFormula returns Exists
	 *     Iff returns Exists
	 *     Iff.Iff_1_0 returns Exists
	 *     If returns Exists
	 *     If.If_1_0 returns Exists
	 *     Xor returns Exists
	 *     Xor.Xor_1_0 returns Exists
	 *     Or returns Exists
	 *     Or.Or_1_0 returns Exists
	 *     And returns Exists
	 *     And.And_1_0 returns Exists
	 *     Quantifier returns Exists
	 *     Exists returns Exists
	 *     BooleanExpression returns Exists
	 *
	 * Constraint:
	 *     (name=Variable iteration=Term formula=Formula)
	 */
	protected void sequence_Exists(ISerializationContext context, Exists semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistsAccess().getNameVariableParserRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExistsAccess().getIterationTermParserRuleCall_5_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getExistsAccess().getFormulaFormulaParserRuleCall_7_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns ForAll
	 *     BinaryFormula returns ForAll
	 *     Iff returns ForAll
	 *     Iff.Iff_1_0 returns ForAll
	 *     If returns ForAll
	 *     If.If_1_0 returns ForAll
	 *     Xor returns ForAll
	 *     Xor.Xor_1_0 returns ForAll
	 *     Or returns ForAll
	 *     Or.Or_1_0 returns ForAll
	 *     And returns ForAll
	 *     And.And_1_0 returns ForAll
	 *     Quantifier returns ForAll
	 *     ForAll returns ForAll
	 *     BooleanExpression returns ForAll
	 *
	 * Constraint:
	 *     (name=Variable iteration=Term formula=Formula)
	 */
	protected void sequence_ForAll(ISerializationContext context, ForAll semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForAllAccess().getNameVariableParserRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getForAllAccess().getIterationTermParserRuleCall_5_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getForAllAccess().getFormulaFormulaParserRuleCall_7_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GetClosure returns GetClosure
	 *
	 * Constraint:
	 *     (initial=Term variable=Variable iteration=Term)
	 */
	protected void sequence_GetClosure(ISerializationContext context, GetClosure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__INITIAL));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GET_CLOSURE__ITERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetClosureAccess().getInitialTermParserRuleCall_2_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getGetClosureAccess().getVariableVariableParserRuleCall_4_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getGetClosureAccess().getIterationTermParserRuleCall_6_0(), semanticObject.getIteration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns GetClosure
	 *     ReferenceBase returns GetClosure
	 *
	 * Constraint:
	 *     (initial=Term variable=Variable iteration=Term get=Get?)
	 */
	protected void sequence_GetClosure_ReferenceBase(ISerializationContext context, GetClosure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetContainer returns GetContainer
	 *
	 * Constraint:
	 *     element=Term
	 */
	protected void sequence_GetContainer(ISerializationContext context, GetContainer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GET_CONTAINER__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GET_CONTAINER__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetContainerAccess().getElementTermParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns GetContainer
	 *     ReferenceBase returns GetContainer
	 *
	 * Constraint:
	 *     (element=Term get=Get?)
	 */
	protected void sequence_GetContainer_ReferenceBase(ISerializationContext context, GetContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GetContainments returns GetContainments
	 *
	 * Constraint:
	 *     element=Term
	 */
	protected void sequence_GetContainments(ISerializationContext context, GetContainments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GET_CONTAINMENTS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GET_CONTAINMENTS__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetContainmentsAccess().getElementTermParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns GetContainments
	 *     ReferenceBase returns GetContainments
	 *
	 * Constraint:
	 *     (element=Term get=Get?)
	 */
	protected void sequence_GetContainments_ReferenceBase(ISerializationContext context, GetContainments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Get returns Get
	 *
	 * Constraint:
	 *     (type=[EClass|ID]? name=[EStructuralFeature|ID] next=Get?)
	 */
	protected void sequence_Get(ISerializationContext context, Get semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns GreaterEqual
	 *     BinaryFormula returns GreaterEqual
	 *     Iff returns GreaterEqual
	 *     Iff.Iff_1_0 returns GreaterEqual
	 *     If returns GreaterEqual
	 *     If.If_1_0 returns GreaterEqual
	 *     Xor returns GreaterEqual
	 *     Xor.Xor_1_0 returns GreaterEqual
	 *     Or returns GreaterEqual
	 *     Or.Or_1_0 returns GreaterEqual
	 *     And returns GreaterEqual
	 *     And.And_1_0 returns GreaterEqual
	 *     Predicate returns GreaterEqual
	 *     Inequality returns GreaterEqual
	 *     GreaterEqual returns GreaterEqual
	 *     BooleanExpression returns GreaterEqual
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_GreaterEqual(ISerializationContext context, GreaterEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterEqualAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterEqualAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Greater
	 *     BinaryFormula returns Greater
	 *     Iff returns Greater
	 *     Iff.Iff_1_0 returns Greater
	 *     If returns Greater
	 *     If.If_1_0 returns Greater
	 *     Xor returns Greater
	 *     Xor.Xor_1_0 returns Greater
	 *     Or returns Greater
	 *     Or.Or_1_0 returns Greater
	 *     And returns Greater
	 *     And.And_1_0 returns Greater
	 *     Predicate returns Greater
	 *     Inequality returns Greater
	 *     Greater returns Greater
	 *     BooleanExpression returns Greater
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Greater(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns If
	 *     BinaryFormula returns If
	 *     Iff returns If
	 *     Iff.Iff_1_0 returns If
	 *     If returns If
	 *     If.If_1_0 returns If
	 *     Xor returns If
	 *     Xor.Xor_1_0 returns If
	 *     Or returns If
	 *     Or.Or_1_0 returns If
	 *     And returns If
	 *     And.And_1_0 returns If
	 *     BooleanExpression returns If
	 *
	 * Constraint:
	 *     (left=If_If_1_0 right=Xor)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IF__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getIfLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIfAccess().getRightXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Iff
	 *     BinaryFormula returns Iff
	 *     Iff returns Iff
	 *     Iff.Iff_1_0 returns Iff
	 *     If returns Iff
	 *     If.If_1_0 returns Iff
	 *     Xor returns Iff
	 *     Xor.Xor_1_0 returns Iff
	 *     Or returns Iff
	 *     Or.Or_1_0 returns Iff
	 *     And returns Iff
	 *     And.And_1_0 returns Iff
	 *     BooleanExpression returns Iff
	 *
	 * Constraint:
	 *     (left=Iff_Iff_1_0 right=If)
	 */
	protected void sequence_Iff(ISerializationContext context, Iff semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IFF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IFF__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IFF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IFF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIffAccess().getIffLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIffAccess().getRightIfParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     domain=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IMPORT__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IMPORT__DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getDomainSTRINGTerminalRuleCall_1_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns IndexOf
	 *     IndexOf returns IndexOf
	 *
	 * Constraint:
	 *     (container=Term element=Term)
	 */
	protected void sequence_IndexOf(ISerializationContext context, IndexOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.INDEX_OF__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.INDEX_OF__CONTAINER));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.INDEX_OF__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.INDEX_OF__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexOfAccess().getContainerTermParserRuleCall_2_0(), semanticObject.getContainer());
		feeder.accept(grammarAccess.getIndexOfAccess().getElementTermParserRuleCall_4_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns IntConstant
	 *     Constant returns IntConstant
	 *     IntConstant returns IntConstant
	 *
	 * Constraint:
	 *     value=SIGNED_INT
	 */
	protected void sequence_IntConstant(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntConstantAccess().getValueSIGNED_INTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns IsEmpty
	 *     BinaryFormula returns IsEmpty
	 *     Iff returns IsEmpty
	 *     Iff.Iff_1_0 returns IsEmpty
	 *     If returns IsEmpty
	 *     If.If_1_0 returns IsEmpty
	 *     Xor returns IsEmpty
	 *     Xor.Xor_1_0 returns IsEmpty
	 *     Or returns IsEmpty
	 *     Or.Or_1_0 returns IsEmpty
	 *     And returns IsEmpty
	 *     And.And_1_0 returns IsEmpty
	 *     Predicate returns IsEmpty
	 *     IsEmpty returns IsEmpty
	 *     BooleanExpression returns IsEmpty
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_IsEmpty(ISerializationContext context, IsEmpty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_EMPTY__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_EMPTY__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsEmptyAccess().getTermTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns IsInstanceOf
	 *     BinaryFormula returns IsInstanceOf
	 *     Iff returns IsInstanceOf
	 *     Iff.Iff_1_0 returns IsInstanceOf
	 *     If returns IsInstanceOf
	 *     If.If_1_0 returns IsInstanceOf
	 *     Xor returns IsInstanceOf
	 *     Xor.Xor_1_0 returns IsInstanceOf
	 *     Or returns IsInstanceOf
	 *     Or.Or_1_0 returns IsInstanceOf
	 *     And returns IsInstanceOf
	 *     And.And_1_0 returns IsInstanceOf
	 *     Predicate returns IsInstanceOf
	 *     IsInstanceOf returns IsInstanceOf
	 *     BooleanExpression returns IsInstanceOf
	 *
	 * Constraint:
	 *     (term=Term type=Term)
	 */
	protected void sequence_IsInstanceOf(ISerializationContext context, IsInstanceOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_INSTANCE_OF__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_INSTANCE_OF__TERM));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_INSTANCE_OF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_INSTANCE_OF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsInstanceOfAccess().getTermTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.accept(grammarAccess.getIsInstanceOfAccess().getTypeTermParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns IsValueLiteralOf
	 *     BinaryFormula returns IsValueLiteralOf
	 *     Iff returns IsValueLiteralOf
	 *     Iff.Iff_1_0 returns IsValueLiteralOf
	 *     If returns IsValueLiteralOf
	 *     If.If_1_0 returns IsValueLiteralOf
	 *     Xor returns IsValueLiteralOf
	 *     Xor.Xor_1_0 returns IsValueLiteralOf
	 *     Or returns IsValueLiteralOf
	 *     Or.Or_1_0 returns IsValueLiteralOf
	 *     And returns IsValueLiteralOf
	 *     And.And_1_0 returns IsValueLiteralOf
	 *     Predicate returns IsValueLiteralOf
	 *     IsValueLiteralOf returns IsValueLiteralOf
	 *     BooleanExpression returns IsValueLiteralOf
	 *
	 * Constraint:
	 *     (term=Term type=Term)
	 */
	protected void sequence_IsValueLiteralOf(ISerializationContext context, IsValueLiteralOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_VALUE_LITERAL_OF__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_VALUE_LITERAL_OF__TERM));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_VALUE_LITERAL_OF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_VALUE_LITERAL_OF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsValueLiteralOfAccess().getTermTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.accept(grammarAccess.getIsValueLiteralOfAccess().getTypeTermParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MetaConstant
	 *     Constant returns MetaConstant
	 *     MetaConstant returns MetaConstant
	 *
	 * Constraint:
	 *     (classifier=[EClassifier|ID] literalOrFeature=[ENamedElement|ID]?)
	 */
	protected void sequence_MetaConstant(ISerializationContext context, MetaConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Not
	 *     BinaryFormula returns Not
	 *     Iff returns Not
	 *     Iff.Iff_1_0 returns Not
	 *     If returns Not
	 *     If.If_1_0 returns Not
	 *     Xor returns Not
	 *     Xor.Xor_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     UnaryFormula returns Not
	 *     Not returns Not
	 *     BooleanExpression returns Not
	 *
	 * Constraint:
	 *     not=Formula
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.NOT__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.NOT__NOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getNotFormulaParserRuleCall_3_0(), semanticObject.getNot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Or
	 *     BinaryFormula returns Or
	 *     Iff returns Or
	 *     Iff.Iff_1_0 returns Or
	 *     If returns Or
	 *     If.If_1_0 returns Or
	 *     Xor returns Or
	 *     Xor.Xor_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     BooleanExpression returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Select
	 *     ReferenceBase returns Select
	 *
	 * Constraint:
	 *     (iteration=Term name=Variable formula=Formula get=Get?)
	 */
	protected void sequence_ReferenceBase_Select(ISerializationContext context, Select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns VariableRef
	 *     ReferenceBase returns VariableRef
	 *
	 * Constraint:
	 *     (name=[Variable|ID] get=Get?)
	 */
	protected void sequence_ReferenceBase_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns Select
	 *
	 * Constraint:
	 *     (iteration=Term name=Variable formula=Formula)
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SELECT__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SELECT__ITERATION));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SELECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SELECT__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SELECT__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SELECT__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getIterationTermParserRuleCall_2_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getSelectAccess().getNameVariableParserRuleCall_4_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSelectAccess().getFormulaFormulaParserRuleCall_6_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Size
	 *     Size returns Size
	 *
	 * Constraint:
	 *     elements=Term
	 */
	protected void sequence_Size(ISerializationContext context, Size semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SIZE__ELEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SIZE__ELEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeAccess().getElementsTermParserRuleCall_2_0(), semanticObject.getElements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns SmallerEqual
	 *     BinaryFormula returns SmallerEqual
	 *     Iff returns SmallerEqual
	 *     Iff.Iff_1_0 returns SmallerEqual
	 *     If returns SmallerEqual
	 *     If.If_1_0 returns SmallerEqual
	 *     Xor returns SmallerEqual
	 *     Xor.Xor_1_0 returns SmallerEqual
	 *     Or returns SmallerEqual
	 *     Or.Or_1_0 returns SmallerEqual
	 *     And returns SmallerEqual
	 *     And.And_1_0 returns SmallerEqual
	 *     Predicate returns SmallerEqual
	 *     Inequality returns SmallerEqual
	 *     SmallerEqual returns SmallerEqual
	 *     BooleanExpression returns SmallerEqual
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_SmallerEqual(ISerializationContext context, SmallerEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmallerEqualAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSmallerEqualAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Smaller
	 *     BinaryFormula returns Smaller
	 *     Iff returns Smaller
	 *     Iff.Iff_1_0 returns Smaller
	 *     If returns Smaller
	 *     If.If_1_0 returns Smaller
	 *     Xor returns Smaller
	 *     Xor.Xor_1_0 returns Smaller
	 *     Or returns Smaller
	 *     Or.Or_1_0 returns Smaller
	 *     And returns Smaller
	 *     And.And_1_0 returns Smaller
	 *     Predicate returns Smaller
	 *     Inequality returns Smaller
	 *     Smaller returns Smaller
	 *     BooleanExpression returns Smaller
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Smaller(ISerializationContext context, Smaller semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmallerAccess().getLeftTermParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSmallerAccess().getRightTermParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns StringConstant
	 *     Constant returns StringConstant
	 *     StringConstant returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringConstant(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConstantAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     name=[Variable|ID]
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getNameVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(FirstOrderLogicPackage.Literals.VARIABLE_REF__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=[EClassifier|ID] name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeEClassifierIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FirstOrderLogicPackage.Literals.VARIABLE__TYPE, false));
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Xor
	 *     BinaryFormula returns Xor
	 *     Iff returns Xor
	 *     Iff.Iff_1_0 returns Xor
	 *     If returns Xor
	 *     If.If_1_0 returns Xor
	 *     Xor returns Xor
	 *     Xor.Xor_1_0 returns Xor
	 *     Or returns Xor
	 *     Or.Or_1_0 returns Xor
	 *     And returns Xor
	 *     And.And_1_0 returns Xor
	 *     BooleanExpression returns Xor
	 *
	 * Constraint:
	 *     (left=Xor_Xor_1_0 right=Or)
	 */
	protected void sequence_Xor(ISerializationContext context, Xor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorAccess().getXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
